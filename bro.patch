diff -urN bro-2.1/.gitignore bro-2.1-sdmbn/.gitignore
--- bro-2.1/.gitignore	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/.gitignore	2014-02-17 17:20:00.000000003 -0600
@@ -1,2 +1 @@
 build
-tmp
diff -urN bro-2.1/README bro-2.1-sdmbn/README
--- bro-2.1/README	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/README	2014-02-17 17:20:00.000000003 -0600
@@ -19,3 +19,13 @@
 International Computer Science Institute &
 Lawrence Berkeley National Laboratory
 vern@icir.org / robin@icir.org
+
+============================
+OpenNF Support
+============================
+
+This code base has been modified by researchers at the University of 
+Wisconsin-Madison to support OpenNF. See the OpenNF home page for more 
+information:
+
+    http://pages.cs.wisc.edu/~agember/opennf
diff -urN bro-2.1/sdmbn_build.sh bro-2.1-sdmbn/sdmbn_build.sh
--- bro-2.1/sdmbn_build.sh	1969-12-31 18:00:00.000000000 -0600
+++ bro-2.1-sdmbn/sdmbn_build.sh	2014-02-17 17:20:06.000000003 -0600
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+export LDFLAGS="-lsdmbn -ljson-c -lboost_serialization"
+
+./configure
+sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/link.txt
+sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/link.txt
+sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/relink.txt
+sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/relink.txt
+make
+make install
diff -urN bro-2.1/src/Analyzer.cc bro-2.1-sdmbn/src/Analyzer.cc
--- bro-2.1/src/Analyzer.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Analyzer.cc	2014-02-17 17:20:06.000000003 -0600
@@ -40,6 +40,11 @@
 #include "Syslog-binpac.h"
 #include "Teredo.h"
 #include "ConnSizeAnalyzer.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/list.hpp>
+#include "SDMBNlocal.h"
 
 // Keep same order here as in AnalyzerTag definition!
 const Analyzer::Config Analyzer::analyzer_configs[] = {
@@ -203,6 +208,27 @@
 	Ref(analyzer->Conn());
 	}
 
+BOOST_CLASS_EXPORT_GUID(AnalyzerTimer,"AnalyzerTimer")
+template<class Archive>
+void AnalyzerTimer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:AnalyzerTimer:%d",__FILE__,__LINE__);
+        // Serialize Timer
+        ar & boost::serialization::base_object<Timer>(*this);
+
+        ar & analyzer;
+       
+        //ar & timer; //FIXME
+
+        ar & do_expire;
+    }
+template void AnalyzerTimer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void AnalyzerTimer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 AnalyzerID Analyzer::id_counter = 0;;
 
 Analyzer* Analyzer::InstantiateAnalyzer(AnalyzerTag::Tag tag, Connection* c)
@@ -248,11 +274,13 @@
 	resp_supporters = 0;
 	signature = 0;
 	output_handler = 0;
+    timers_canceled = false;
+    moved = false;
 	}
 
 Analyzer::~Analyzer()
 	{
-	assert(finished);
+	//assert(moved || finished); // SDMBN-FIXME
 
 	LOOP_OVER_CHILDREN(i)
 		delete *i;
@@ -272,6 +300,9 @@
 		}
 
 	delete output_handler;
+
+    if (moved)
+    { CancelTimers(); }
 	}
 
 void Analyzer::Init()
@@ -291,6 +322,9 @@
 
 void Analyzer::Done()
 	{
+    if (moved)
+    { return; }
+
 	assert(!finished);
 
 	if ( ! skip )
@@ -863,6 +897,86 @@
 		(*i)->UpdateConnVal(conn_val);
 	}
 
+void Analyzer::Moved()
+    {
+    moved = true;
+	
+	for ( SupportAnalyzer* a = orig_supporters; a; a = a->sibling )
+    { a->Moved(); }
+
+	for ( SupportAnalyzer* a = resp_supporters; a; a = a->sibling )
+    { a->Moved(); }
+
+    for (std::list<Analyzer*>::iterator it = children.begin(); 
+              it != children.end(); it++)
+    { (*it)->Moved(); }
+        
+    for (std::list<Analyzer*>::iterator it = new_children.begin(); 
+            it != new_children.end(); it++)
+    { (*it)->Moved(); }
+    }
+
+BOOST_CLASS_EXPORT_GUID(Analyzer,"Analyzer")
+template<class Archive>
+void Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Analyzer:%d",__FILE__,__LINE__);
+
+        ar & tag;
+        ar & id;
+        ar & conn; 
+
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            if (parent != NULL)
+            { assert(sdmbn_can_serialize(parent->GetTag())); }
+        }
+        SERIALIZE_PRINT("\t\tAnalyzer:%d",__LINE__);
+        ar & parent;
+        //ar & signature; //Include? Does not seem to be used
+        if (Archive::is_loading::value) { signature = NULL; }
+        //ar & output_handler //Include? Only used in HTTP.cc:190
+        if (Archive::is_loading::value) { output_handler = NULL; }
+        
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            for (std::list<Analyzer*>::iterator it = children.begin(); 
+                    it != children.end(); it++)
+            { assert(sdmbn_can_serialize((*it)->GetTag())); }
+
+            if (orig_supporters != NULL)
+            { assert(sdmbn_can_serialize(orig_supporters->GetTag())); }
+        
+            if (resp_supporters != NULL)
+            { assert(sdmbn_can_serialize(resp_supporters->GetTag())); }
+        
+            for (std::list<Analyzer*>::iterator it = new_children.begin(); 
+                    it != new_children.end(); it++)
+            { assert(sdmbn_can_serialize((*it)->GetTag())); }
+        }
+        ar & children;
+        ar & orig_supporters;
+        ar & resp_supporters;
+        ar & new_children;
+
+        SERIALIZE_PRINT("\t\tAnalyzer:%d",__LINE__);
+        ar & protocol_confirmed;
+        //ar & timers; //FIXME //Should include?
+        ar & timers_canceled;
+        ar & skip;
+        ar & finished;
+        ar & removing;
+        SERIALIZE_PRINT("\t\tAnalyzer:Done");
+    }
+template void Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
+
 void SupportAnalyzer::ForwardPacket(int len, const u_char* data, bool is_orig,
 					int seq, const IP_Hdr* ip, int caplen)
 	{
@@ -906,6 +1020,26 @@
 		Parent()->Undelivered(seq, len, is_orig);
 	}
 
+BOOST_CLASS_EXPORT_GUID(SupportAnalyzer,"SupportAnalyzer")
+template<class Archive>
+void SupportAnalyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:SupportAnalyzer:%d",__FILE__,__LINE__);
+
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>( *this );
+
+        SERIALIZE_PRINT("\t\tSupportAnalyzer:%d",__LINE__);
+        ar & orig;
+        ar & sibling;
+        SERIALIZE_PRINT("\t\tSupportAnalyzer:Done");
+    }
+template void SupportAnalyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void SupportAnalyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
 
 void TransportLayerAnalyzer::Done()
 	{
@@ -934,3 +1068,23 @@
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(TransportLayerAnalyzer,"TransportLayerAnalyzer")
+template<class Archive>
+void TransportLayerAnalyzer::serialize(Archive & ar, 
+        const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TransportLayerAnalyzer:%d",__FILE__,__LINE__);
+
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>(*this);
+
+        SERIALIZE_PRINT("\t\tTransportLayerAnalyzer:%d",__LINE__);
+        ar & pia;
+        SERIALIZE_PRINT("\t\tTransportLayerAnalyzer:Done");
+    }
+template void TransportLayerAnalyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TransportLayerAnalyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
diff -urN bro-2.1/src/Analyzer.h bro-2.1-sdmbn/src/Analyzer.h
--- bro-2.1/src/Analyzer.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Analyzer.h	2014-02-17 17:20:06.000000003 -0600
@@ -8,6 +8,7 @@
 #include "AnalyzerTags.h"
 #include "Conn.h"
 #include "Obj.h"
+#include <boost/serialization/access.hpp>
 
 class DPM;
 class PIA;
@@ -36,6 +37,10 @@
 	Analyzer* analyzer;
 	analyzer_timer_func timer;
 	int do_expire;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 
@@ -253,6 +258,9 @@
 
 	// Factory function to instantiate new analyzers.
 	static Analyzer* InstantiateAnalyzer(AnalyzerTag::Tag tag, Connection* c);
+    
+    void Moved();
+    bool HasMoved() { return moved; }
 
 protected:
 	friend class DPM;
@@ -260,7 +268,7 @@
 	friend class AnalyzerTimer;
 	friend class TCP_ApplicationAnalyzer;
 
-	Analyzer()	{ }
+	Analyzer()	{ moved = false; }
 
 	// Associates a connection with this analyzer.  Must be called if
 	// we're using the default ctor.
@@ -326,6 +334,11 @@
 	// Table of analyzers.
 	static const Config analyzer_configs[];
 
+    bool moved;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #define ADD_ANALYZER_TIMER(timer, t, do_expire, type) \
@@ -373,8 +386,11 @@
 	// Points to next support analyzer in chain.  The list is managed by
 	// parent analyzer.
 	SupportAnalyzer* sibling;
-};
 
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+};
 
 class TransportLayerAnalyzer : public Analyzer {
 public:
@@ -398,6 +414,10 @@
 
 private:
 	PIA* pia;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/Attr.cc bro-2.1-sdmbn/src/Attr.cc
--- bro-2.1/src/Attr.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Attr.cc	2014-02-17 17:20:06.000000003 -0600
@@ -6,6 +6,10 @@
 #include "Expr.h"
 #include "Serializer.h"
 #include "threading/SerialTypes.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 const char* attr_name(attr_tag t)
 	{
@@ -548,3 +552,21 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(Attributes,"Attributes")
+template<class Archive>
+void Attributes::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Attributes:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        ar & type;
+        ar & attrs;
+        ar & in_record;
+    }
+template void Attributes::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Attributes::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/Attr.h bro-2.1-sdmbn/src/Attr.h
--- bro-2.1/src/Attr.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Attr.h	2014-02-17 17:20:06.000000003 -0600
@@ -4,6 +4,7 @@
 #define attr_h
 
 #include "Obj.h"
+#include <boost/serialization/access.hpp>
 
 class Expr;
 
@@ -107,6 +108,10 @@
 	BroType* type;
 	attr_list* attrs;
 	bool in_record;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/Base64.cc bro-2.1-sdmbn/src/Base64.cc
--- bro-2.1/src/Base64.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Base64.cc	2014-02-17 17:20:06.000000003 -0600
@@ -1,5 +1,10 @@
 #include "config.h"
 #include "Base64.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 int Base64Decoder::default_base64_table[256];
 const string Base64Decoder::default_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
@@ -163,6 +168,46 @@
 	return 0;
 	}
 
+BOOST_CLASS_EXPORT_GUID(Base64Decoder,"Base64Decoder")
+template<class Archive>
+void Base64Decoder::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Base64Decoder:%d",__FILE__,__LINE__);
+
+        ar & error_msg;
+        ar & base64_group;
+        ar & base64_group_next;
+        ar & base64_padding;
+        ar & base64_after_padding;
+        ar & errored;
+
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            if (analyzer != NULL)
+            { assert(sdmbn_can_serialize(analyzer->GetTag())); }
+        }
+        ar & analyzer;
+
+        // Special handling of base64_table
+        if (!Archive::is_loading::value)
+        { 
+            ar & boost::serialization::make_binary_object(base64_table,
+                    256*sizeof(int)); 
+        }
+        if (Archive::is_loading::value)
+        {
+            base64_table = new int[256];
+            ar & boost::serialization::make_binary_object(base64_table,
+                    256*sizeof(int));
+        }
+    }
+template void Base64Decoder::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Base64Decoder::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 BroString* decode_base64(const BroString* s, const BroString* a)
 	{
diff -urN bro-2.1/src/Base64.h bro-2.1-sdmbn/src/Base64.h
--- bro-2.1/src/Base64.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Base64.h	2014-02-17 17:20:06.000000003 -0600
@@ -8,6 +8,7 @@
 #include "util.h"
 #include "BroString.h"
 #include "Analyzer.h"
+#include <boost/serialization/access.hpp>
 
 // Maybe we should have a base class for generic decoders?
 
@@ -62,6 +63,12 @@
 	static int* InitBase64Table(const string& alphabet);
 	static int default_base64_table[256];
 	static const string default_alphabet;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    Base64Decoder() {}; // Dummy default constructor for serialization
 };
 
 BroString* decode_base64(const BroString* s, const BroString* a = 0);
diff -urN bro-2.1/src/BroString.cc bro-2.1-sdmbn/src/BroString.cc
--- bro-2.1/src/BroString.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/BroString.cc	2014-02-17 17:20:06.000000003 -0600
@@ -10,6 +10,11 @@
 #include "BroString.h"
 #include "Var.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 #ifdef DEBUG
 #define DEBUG_STR(msg) DBG_LOG(DBG_STRING, msg)
@@ -61,6 +66,7 @@
 	{
 	b = 0;
 	n = 0;
+	final_NUL = 0;
 	use_free_to_delete = 0;
 	*this = bs;
 	}
@@ -408,6 +414,51 @@
 	return strdup(result.c_str());
 	}
 
+BOOST_CLASS_EXPORT_GUID(BroString,"BroString")
+template<class Archive>
+void BroString::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BroString:%d",__FILE__,__LINE__);
+
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (final_NUL << 0);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            final_NUL = (bitfields >> 0) & 0x1;
+        }
+
+        ar & n;
+
+        // Special handling of buffer
+        if (!Archive::is_loading::value)
+        {
+            if (n > 0)
+            { ar & boost::serialization::make_binary_object(b, n+final_NUL); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (n > 0)
+            {
+                b = new u_char[n + final_NUL];
+                ar & boost::serialization::make_binary_object(b, n+final_NUL);
+                use_free_to_delete = 0;
+            }
+            else
+            { b = 0; }
+        }
+    }
+template void BroString::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BroString::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 bool BroStringLenCmp::operator()(BroString * const& bst1,
 				 BroString * const& bst2)
 	{
@@ -500,6 +551,12 @@
 	return concatenate(cv);
 	}
 
+void delete_strings(std::vector<BroString*>& v)
+	{
+	for ( unsigned int i = 0; i < v.size(); ++i )
+		delete v[i];
+	v.clear();
+	}
 void delete_strings(std::vector<const BroString*>& v)
 	{
 	for ( unsigned int i = 0; i < v.size(); ++i )
diff -urN bro-2.1/src/BroString.h bro-2.1-sdmbn/src/BroString.h
--- bro-2.1/src/BroString.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/BroString.h	2014-02-17 17:20:06.000000003 -0600
@@ -8,6 +8,7 @@
 #include <iostream>
 #include <stdlib.h>
 #include <sys/types.h>
+#include <boost/serialization/access.hpp>
 using namespace std;
 
 #include "util.h"
@@ -150,6 +151,10 @@
 	int n;
 	unsigned int final_NUL:1;	// whether we have added a final NUL
 	unsigned int use_free_to_delete:1;	// free() vs. operator delete
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // A comparison class that sorts pointers to BroString's according to
@@ -186,6 +191,7 @@
 extern BroString* concatenate(std::vector<data_chunk_t>& v);
 extern BroString* concatenate(BroString::Vec& v);
 extern BroString* concatenate(BroString::CVec& v);
+extern void delete_strings(std::vector<BroString*>& v);
 extern void delete_strings(std::vector<const BroString*>& v);
 
 #endif
diff -urN bro-2.1/src/CMakeLists.txt bro-2.1-sdmbn/src/CMakeLists.txt
--- bro-2.1/src/CMakeLists.txt	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/CMakeLists.txt	2014-02-17 17:20:06.000000003 -0600
@@ -378,6 +378,7 @@
     RuleCondition.cc
     RuleMatcher.cc
     ScriptAnaly.cc
+    SDMBNlocal.cc
     SmithWaterman.cc
     SMB.cc
     SMTP.cc
diff -urN bro-2.1/src/code.tmp bro-2.1-sdmbn/src/code.tmp
--- bro-2.1/src/code.tmp	1969-12-31 18:00:00.000000000 -0600
+++ bro-2.1-sdmbn/src/code.tmp	2014-02-17 17:20:07.000000003 -0600
@@ -0,0 +1,45 @@
+        if (Archive::is_loading::value) {  = NULL; } //TMPHACK
+
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <SDMBN.h>
+#include "SDMBNlocal.h"
+
+#include <boost/serialization/list.hpp>
+
+BOOST_CLASS_EXPORT_GUID(,"")
+template<class Archive>
+void ::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s::%d",__FILE__,__LINE__);
+        // Serialize 
+        ar & boost::serialization::base_object<>(*this);
+    }
+template void ::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
+#include <boost/serialization/binary_object.hpp>
+
+        // Special handling of buffer
+        if (!Archive::is_loading::value)
+        { ar & boost::serialization::make_binary_object(buf, buf_len); }
+        if (Archive::is_loading::value)
+        {
+            buf = new u_char[buf_len];
+            ar & boost::serialization::make_binary_object(buf, buf_len);
+        }
+
+#include <boost/serialization/access.hpp>
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    () {}; // Dummy default constructor for serialization
+
+
diff -urN bro-2.1/src/CompHash.cc bro-2.1-sdmbn/src/CompHash.cc
--- bro-2.1/src/CompHash.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/CompHash.cc	2014-02-17 17:20:06.000000003 -0600
@@ -6,6 +6,11 @@
 #include "Val.h"
 #include "Reporter.h"
 #include "Func.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 CompositeHash::CompositeHash(TypeList* composite_type)
 	{
@@ -917,3 +922,38 @@
 
 	return kp1;
 	}
+
+BOOST_CLASS_EXPORT_GUID(CompositeHash,"Compositehash")
+template<class Archive>
+void CompositeHash::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & type;
+        ar & size;
+
+        // Special handling of key 
+        if (!Archive::is_loading::value)
+        { 
+            if (size > 0)
+            { ar & boost::serialization::make_binary_object(key, size); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (size > 0)
+            {
+                key = new char[size];
+                ar & boost::serialization::make_binary_object(key, size);
+            }
+            else
+            { key = NULL; }
+        }
+
+        ar & is_singleton;
+        ar & is_complex_type;
+        ar & singleton_tag;
+    }
+template void CompositeHash::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void CompositeHash::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/CompHash.h bro-2.1-sdmbn/src/CompHash.h
--- bro-2.1/src/CompHash.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/CompHash.h	2014-02-17 17:20:06.000000003 -0600
@@ -5,6 +5,7 @@
 
 #include "Hash.h"
 #include "Type.h"
+#include <boost/serialization/access.hpp>
 
 class ListVal;
 
@@ -88,6 +89,12 @@
 	int is_complex_type;
 
 	InternalTypeTag singleton_tag;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    CompositeHash() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/Conn.cc bro-2.1-sdmbn/src/Conn.cc
--- bro-2.1/src/Conn.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Conn.cc	2014-02-17 17:20:06.000000003 -0600
@@ -14,6 +14,10 @@
 #include "PIA.h"
 #include "binpac.h"
 #include "TunnelEncapsulation.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 void ConnectionTimer::Init(Connection* arg_conn, timer_func arg_timer,
 				int arg_do_expire)
@@ -106,6 +110,62 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(ConnectionTimer,"ConnectionTimer")
+template<class Archive>
+void ConnectionTimer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:ConnectionTimer:%d",__FILE__,__LINE__);
+        // Serialize Timer
+        ar & boost::serialization::base_object<Timer>(*this);
+
+        ar & conn;
+
+        // Special handling of timer
+        char type = 0;
+        if (!Archive::is_loading::value)
+        {
+            if ( timer == timer_func(&Connection::DeleteTimer) )
+                type = 'D';
+            else if ( timer == timer_func(&Connection::InactivityTimer) )
+                type = 'I';
+            else if ( timer == timer_func(&Connection::StatusUpdateTimer) )
+                type = 'S';
+            else if ( timer == timer_func(&Connection::RemoveConnectionTimer) )
+                type = 'R';
+            else
+                assert("Unkown timer type" && false);
+        }
+        ar & type;
+        if (Archive::is_loading::value)
+        {
+            switch(type)
+            {
+            case 'D':
+                timer = timer_func(&Connection::DeleteTimer);
+                break;
+            case'I':
+                timer = timer_func(&Connection::InactivityTimer);
+                break;
+            case 'S':
+                timer = timer_func(&Connection::StatusUpdateTimer);
+                break;
+            case 'R':
+                timer = timer_func(&Connection::RemoveConnectionTimer);
+                break;
+            default:
+                assert("Unkown timer type" && false);
+            }
+        }
+
+        ar & do_expire;
+    }
+template void ConnectionTimer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ConnectionTimer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 unsigned int Connection::total_connections = 0;
 unsigned int Connection::current_connections = 0;
 unsigned int Connection::external_connections = 0;
@@ -175,13 +235,29 @@
 		ADD_TIMER(&Connection::RemoveConnectionTimer, 1e20, 1,
 				TIMER_REMOVE_CONNECTION);
 		}
+
+    moved = false; // Flag to indicate object has moved
+
+    // initialize pthread here
+    assert(0 == pthread_mutex_init(&lock, NULL));
 	}
 
+Connection::Connection()
+    {
+        persistent = 0;
+        moved = false; // Flag to indicate object has moved
+        // initialize pthread here
+        assert(0 == pthread_mutex_init(&lock, NULL));
+    }
+
 Connection::~Connection()
 	{
-	if ( ! finished )
+	if ( ! finished && !moved )
 		reporter->InternalError("Done() not called before destruction of Connection");
 
+    // destroy mutex
+    pthread_mutex_destroy(&lock);
+
 	CancelTimers();
 
 	if ( conn_val )
@@ -966,3 +1042,120 @@
 	else
 		saw_first_resp_packet = 1;
 	}
+
+void Connection::Moved()
+    {
+    moved = true;
+    if (root_analyzer)
+    { root_analyzer->Moved(); }
+    }
+
+BOOST_CLASS_EXPORT_GUID(Connection,"Connection")
+template<class Archive>
+void Connection::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Connection:%d",__FILE__,__LINE__);
+
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        // Special handling of sessions field
+        if (Archive::is_loading::value)
+        { sessions = ::sessions; }
+
+        ar & key; 
+
+        // Special handling of conn_timer_mgr
+        if (!Archive::is_loading::value)
+        {
+            if (conn_timer_mgr)
+            {
+                // Use local conn_timer_mgr
+            }
+            else
+            {
+                // Use global conn_timer_mgr
+            }
+        }
+        //ar & conn_timer_mgr; // Not sure if this should be included
+        if (Archive::is_loading::value) { conn_timer_mgr = NULL; } //TMPHACK
+        //ar & timers; // Not sure if this should be included
+        ar &  orig_addr;
+        ar &  resp_addr;
+        ar &  orig_port; 
+        ar &  resp_port; 
+        ar &  proto;
+        ar &  orig_flow_label; 
+        ar &  resp_flow_label; 
+        ar &  start_time; 
+        ar &  last_time; 
+        ar &  inactivity_timeout; 
+
+        // Special handling of conn_val field
+        if (Archive::is_loading::value) 
+        { 
+            // Set conn_val to NULL, so it is rebuilt if needed
+            conn_val = NULL; 
+        } 
+    
+        // Special handling of login_conn field
+        bool has_login_conn = false;
+        if (!Archive::is_loading::value)
+        { has_login_conn = (true && login_conn); }
+        ar & has_login_conn;
+        if (Archive::is_loading::value)
+        { login_conn = has_login_conn ? (LoginConn*) this : 0; }
+
+//        ar &  encapsulation; //Beware: this is a vector of related conns //REINCLUDE
+        if (Archive::is_loading::value) { encapsulation = NULL; } //TMPHACK
+        ar &  suppress_event; 
+
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (installed_status_timer << 0);
+            bitfields |= (timers_canceled << 1);
+            bitfields |= (is_active << 2); 
+            bitfields |= (skip << 3);
+            bitfields |= (weird << 4);
+            bitfields |= (finished << 5);
+            bitfields |= (record_packets << 6);
+            bitfields |= (record_contents << 7);
+            bitfields |= (persistent << 8);
+            bitfields |= (record_current_packet << 9);
+            bitfields |= (record_current_content << 10);
+            bitfields |= (saw_first_orig_packet << 11);
+            bitfields |= (saw_first_resp_packet << 12);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            installed_status_timer = (bitfields >> 0) & 0x1;
+            timers_canceled = (bitfields >> 1) & 0x1;
+            is_active = (bitfields >> 2) & 0x1; 
+            skip = (bitfields >> 3) & 0x1;
+            weird = (bitfields >> 4) & 0x1;
+            finished = (bitfields >> 5) & 0x1;
+            record_packets = (bitfields >> 6) & 0x1;
+            record_contents = (bitfields >> 7) & 0x1;
+            persistent = (bitfields >> 8) & 0x1;
+            record_current_packet = (bitfields >> 9) & 0x1;
+            record_current_content = (bitfields >> 10) & 0x1;
+            saw_first_orig_packet = (bitfields >> 11) & 0x1;
+            saw_first_resp_packet = (bitfields >> 12) & 0x1;
+        }
+
+        ar & history;
+        ar & hist_seen;
+        ar & root_analyzer;
+        ar & primary_PIA;
+        ar & uid;
+        SERIALIZE_PRINT("\t\tConnection:Done");
+    }
+template void Connection::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Connection::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/Conn.h bro-2.1-sdmbn/src/Conn.h
--- bro-2.1/src/Conn.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Conn.h	2014-02-17 17:20:06.000000003 -0600
@@ -14,6 +14,7 @@
 #include "AnalyzerTags.h"
 #include "IPAddr.h"
 #include "TunnelEncapsulation.h"
+#include <boost/serialization/access.hpp>
 
 class Connection;
 class ConnectionTimer;
@@ -23,6 +24,7 @@
 class Specific_RE_Matcher;
 class TransportLayerAnalyzer;
 class RuleEndpointState;
+class PIA;
 
 typedef enum {
 	NUL_IN_LINE,
@@ -256,10 +258,25 @@
 		{ return encapsulation; }
 
 	void CheckFlowLabel(bool is_orig, uint32 flow_label);
+	
+    Connection();
 
-protected:
+    void Moved();
+    bool HasMoved() { return moved; }
+
+    // manipulation methods for dirty marker
+    bool isDirty() { return dirty; }
+    void setDirty(bool dirtyVal) { dirty = dirtyVal; }
+    int dirtyBackoff() { return dirty_backoff; }
+    void setDirtyBackoff(int dirtyBackoff) { dirty_backoff = dirtyBackoff; } 
+    int getGetOpId() { return getOpId; }
+    void setGetOpId(int opId) { getOpId = opId; }
+    void initLock() { assert(0 == pthread_mutex_init(&lock, NULL)); /* = PTHREAD_MUTEX_INITIALIZER; */ }
+	uint32_t getOpId; /* last SDMBN get call that returned this */
+    // keep a lock per connection
+    pthread_mutex_t lock;
 
-	Connection()	{ persistent = 0; }
+protected:
 
 	// Add the given timer to expire at time t.  If do_expire
 	// is true, then the timer is also evaluated when Bro terminates,
@@ -318,6 +335,16 @@
 	PIA* primary_PIA;
 
 	uint64 uid;	// Globally unique connection ID.
+
+    bool moved;
+
+    // mark a connection as dirty
+    bool dirty;
+    int dirty_backoff;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class ConnectionTimer : public Timer {
@@ -340,6 +367,10 @@
 	Connection* conn;
 	timer_func timer;
 	int do_expire;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #define ADD_TIMER(timer, t, do_expire, type) \
diff -urN bro-2.1/src/ConnSizeAnalyzer.cc bro-2.1-sdmbn/src/ConnSizeAnalyzer.cc
--- bro-2.1/src/ConnSizeAnalyzer.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ConnSizeAnalyzer.cc	2014-02-17 17:20:06.000000003 -0600
@@ -5,6 +5,9 @@
 
 #include "ConnSizeAnalyzer.h"
 #include "TCP.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 
 
@@ -86,3 +89,21 @@
 	resp_pkts = tmp;
 	}
 
+BOOST_CLASS_EXPORT_GUID(ConnSize_Analyzer,"ConnSize_Analyzer")
+template<class Archive>
+void ConnSize_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>(*this);
+
+        ar & orig_bytes;
+        ar & resp_bytes;
+        ar & orig_pkts;
+        ar & resp_pkts;
+    }
+template void ConnSize_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ConnSize_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/ConnSizeAnalyzer.h bro-2.1-sdmbn/src/ConnSizeAnalyzer.h
--- bro-2.1/src/ConnSizeAnalyzer.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ConnSizeAnalyzer.h	2014-02-17 17:20:06.000000003 -0600
@@ -6,6 +6,7 @@
 
 #include "Analyzer.h"
 #include "NetVar.h"
+#include <boost/serialization/access.hpp>
 
 
 class ConnSize_Analyzer : public Analyzer {
@@ -34,6 +35,12 @@
 	uint64_t resp_bytes;
 	uint64_t orig_pkts;
 	uint64_t resp_pkts;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    ConnSize_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/ContentLine.cc bro-2.1-sdmbn/src/ContentLine.cc
--- bro-2.1/src/ContentLine.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ContentLine.cc	2014-02-17 17:20:06.000000003 -0600
@@ -2,6 +2,11 @@
 
 #include "ContentLine.h"
 #include "TCP.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 ContentLine_Analyzer::ContentLine_Analyzer(Connection* conn, bool orig)
 : TCP_SupportAnalyzer(AnalyzerTag::ContentLine, conn, orig)
@@ -23,6 +28,9 @@
 	skip_deliveries = 0;
 	skip_partial = 0;
 	buf = 0;
+    offset = 0;
+    buf_len = 0;
+    last_char = 0;
 	seq_delivered_in_lines = 0;
 	skip_pending = 0;
 	seq = 0;
@@ -332,3 +340,61 @@
 	seq_to_skip = SeqDelivered() + length;
 	}
 
+BOOST_CLASS_EXPORT_GUID(ContentLine_Analyzer,"ContentLine_Analyzer")
+template<class Archive>
+void ContentLine_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_SupportAnalyzer
+        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
+
+        ar & buf_len;
+
+        // Special handling of buffer
+        if (!Archive::is_loading::value)
+        { 
+            if (buf_len > 0)
+            { ar & boost::serialization::make_binary_object(buf, buf_len); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (buf_len > 0)
+            {
+                buf = new u_char[buf_len];
+                ar & boost::serialization::make_binary_object(buf, buf_len);
+            }
+            else
+            { buf = 0; }
+        }
+
+        ar & offset;
+        ar & last_char;
+        ar & seq;
+        ar & seq_to_skip;
+        ar & seq_delivered_in_lines;
+        ar & skip_pending;
+        ar & plain_delivery_length;
+        ar & is_plain;
+        ar & skip_deliveries;
+
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (flag_NULs << 0);
+            bitfields |= (CR_LF_as_EOL << 1);
+            bitfields |= (skip_partial << 3);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            flag_NULs = (bitfields >> 0) & 0x1;
+            CR_LF_as_EOL = (bitfields >> 1) & 0x3;
+            skip_partial = (bitfields >> 3) & 0x1;
+        }
+    }
+template void ContentLine_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ContentLine_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/ContentLine.h bro-2.1-sdmbn/src/ContentLine.h
--- bro-2.1/src/ContentLine.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ContentLine.h	2014-02-17 17:20:06.000000003 -0600
@@ -4,6 +4,7 @@
 #define CONTENTLINE_H
 
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
 
 #define CR_as_EOL 1
 #define LF_as_EOL 2
@@ -102,6 +103,28 @@
 
 	// Whether to skip partial conns.
 	unsigned int skip_partial:1;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    ContentLine_Analyzer() 
+    {
+        buf_len = 0;
+        offset = 0;
+        last_char = 0;
+        flag_NULs = 0;
+        CR_LF_as_EOL = (CR_as_EOL | LF_as_EOL);
+        skip_deliveries = 0;
+        skip_partial = 0;
+        buf = 0;
+        seq_delivered_in_lines = 0;
+        skip_pending = 0;
+        seq = 0;
+        seq_to_skip = 0;
+        plain_delivery_length = 0;
+        is_plain = 0;
+    }; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/DNS.cc bro-2.1-sdmbn/src/DNS.cc
--- bro-2.1/src/DNS.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/DNS.cc	2014-02-17 17:20:06.000000003 -0600
@@ -11,6 +11,11 @@
 #include "DNS.h"
 #include "Sessions.h"
 #include "Event.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 DNS_Interpreter::DNS_Interpreter(Analyzer* arg_analyzer)
 	{
@@ -859,6 +864,18 @@
 	analyzer->ConnectionEvent(event, vl);
 	}
 
+BOOST_CLASS_EXPORT_GUID(DNS_Interpreter,"DNS_Interpreter")
+template<class Archive>
+void DNS_Interpreter::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & analyzer; 
+    }
+template void DNS_Interpreter::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void DNS_Interpreter::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 DNS_MsgInfo::DNS_MsgInfo(DNS_RawMsgHdr* hdr, int arg_is_query)
 	{
@@ -1079,6 +1096,37 @@
 		DeliverStream(len - n, data + n, orig);
 	}
 
+BOOST_CLASS_EXPORT_GUID(Contents_DNS,"Contents_DNS")
+template<class Archive>
+void Contents_DNS::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_SupportAnalyzer
+        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
+
+        ar & interp;
+        ar & buf_n;
+        ar & buf_len;
+
+        // Special handling of buffer
+        if (!Archive::is_loading::value)
+        { ar & boost::serialization::make_binary_object(msg_buf, buf_len); }
+        if (Archive::is_loading::value)
+        {
+            msg_buf = (u_char*)malloc(buf_len);
+            assert(msg_buf != NULL);
+            ar & boost::serialization::make_binary_object(msg_buf, buf_len);
+        }
+
+        ar & msg_size;
+        ar & state;
+    }
+template void Contents_DNS::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Contents_DNS::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 DNS_Analyzer::DNS_Analyzer(Connection* conn)
 : TCP_ApplicationAnalyzer(AnalyzerTag::DNS, conn)
 	{
@@ -1165,3 +1213,25 @@
 		ADD_ANALYZER_TIMER(&DNS_Analyzer::ExpireTimer,
 				t + dns_session_timeout, 1, TIMER_DNS_EXPIRE);
 	}
+
+BOOST_CLASS_EXPORT_GUID(DNS_Analyzer,"DNS_Analyzer")
+template<class Archive>
+void DNS_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:DNS_Analyzer:%d",__FILE__,__LINE__);
+
+        // Serialize TransportLayerAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & interp;
+        ar & contents_dns_orig;
+        ar & contents_dns_resp;
+        ar & did_session_done;
+        SERIALIZE_PRINT("DNS_Analyzer:Done");
+    }
+template void DNS_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void DNS_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
diff -urN bro-2.1/src/DNS.h bro-2.1-sdmbn/src/DNS.h
--- bro-2.1/src/DNS.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/DNS.h	2014-02-17 17:20:06.000000003 -0600
@@ -5,6 +5,7 @@
 
 #include "TCP.h"
 #include "binpac_bro.h"
+#include <boost/serialization/access.hpp>
 
 typedef enum {
 	DNS_OP_QUERY = 0,		///< standard query
@@ -218,6 +219,12 @@
 					BroString* question_name);
 
 	Analyzer* analyzer;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    DNS_Interpreter() {}; // Dummy default constructor for serialization
 };
 
 
@@ -248,6 +255,12 @@
 	int buf_len;		///< size of msg_buf
 	int msg_size;		///< expected size of message
 	TCP_DNS_state state;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    Contents_DNS() {}; // Dummy default constructor for serialization
 };
 
 // Works for both TCP and UDP.
@@ -280,6 +293,12 @@
 	Contents_DNS* contents_dns_orig;
 	Contents_DNS* contents_dns_resp;
 	int did_session_done;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    DNS_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 // FIXME: Doesn't really fit into new analyzer structure. What to do?
diff -urN bro-2.1/src/FileAnalyzer.cc bro-2.1-sdmbn/src/FileAnalyzer.cc
--- bro-2.1/src/FileAnalyzer.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/FileAnalyzer.cc	2014-02-17 17:20:06.000000003 -0600
@@ -2,6 +2,9 @@
 
 #include "FileAnalyzer.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 magic_t File_Analyzer::magic = 0;
 magic_t File_Analyzer::magic_mime = 0;
@@ -76,3 +79,20 @@
 		*magic = 0;
 		}
 	}
+
+BOOST_CLASS_EXPORT_GUID(File_Analyzer,"File_Analyzer")
+template<class Archive>
+void File_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & buffer;
+        ar & buffer_len;
+    }
+template void File_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void File_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/FileAnalyzer.h bro-2.1-sdmbn/src/FileAnalyzer.h
--- bro-2.1/src/FileAnalyzer.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/FileAnalyzer.h	2014-02-17 17:20:06.000000003 -0600
@@ -4,6 +4,7 @@
 #define FILEANALYZER_H
 
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
 
 #include <magic.h>
 
@@ -33,6 +34,10 @@
 
 	static magic_t magic;
 	static magic_t magic_mime;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/File.cc bro-2.1-sdmbn/src/File.cc
--- bro-2.1/src/File.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/File.cc	2014-02-17 17:20:06.000000003 -0600
@@ -29,6 +29,11 @@
 #include "Serializer.h"
 #include "Event.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 // Timer which on dispatching rotates the file.
 class RotateTimer : public Timer {
@@ -708,6 +713,7 @@
 
 	int buf_size = MIN_BUFFER_SIZE + EVP_CIPHER_block_size(cipher_type);
 	cipher_buffer = new unsigned char[buf_size];
+    cipher_size = buf_size;
 	}
 
 void BroFile::FinishEncrypt()
@@ -974,3 +980,122 @@
 
 	return true;
 	}
+
+BOOST_CLASS_EXPORT_GUID(BroFile,"BroFile")
+template<class Archive>
+void BroFile::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BroFile:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        //ar & f; //FIXME
+        if (Archive::is_loading::value) { f = NULL; } //TMPHACK
+        ar & t;
+
+        // Special handling of name
+        int name_size;
+        if (!Archive::is_loading::value)
+        {
+            if (name)
+            { name_size = strlen(name); }
+            else
+            { name_size = 0; }
+        }
+        ar & name_size;
+        if (!Archive::is_loading::value)
+        { 
+            if (name_size > 0)
+            { ar & boost::serialization::make_binary_object(name, name_size); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (name_size > 0)
+            {
+                name = new char[name_size];
+                ar & boost::serialization::make_binary_object(name, name_size);
+            }
+            else
+            { name = NULL; }
+        }
+
+        // Special handling of access
+        int access_size;
+        if (!Archive::is_loading::value)
+        {
+            if (access)
+            { access_size = strlen(access); }
+            else
+            { access_size = 0; }
+        }
+        ar & access_size;
+        if (!Archive::is_loading::value)
+        { 
+            if (access_size > 0)
+            { 
+                ar & boost::serialization::make_binary_object(access,
+                        access_size); 
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (access_size > 0)
+            {
+                access = new char[access_size];
+                ar & boost::serialization::make_binary_object(access,
+                       access_size);
+            }
+            else
+            { access = NULL; }
+        }
+
+        ar & is_in_cache;
+        ar & is_open;
+        ar & okay_to_manage;
+        ar & position;
+        ar & next;
+        ar & prev;
+        ar & attrs;
+        ar & rotate_interval;
+        ar & buffered;
+        ar & rotate_size;
+        ar & current_size;
+        //ar & rotate_timer; //FIXME
+        if (Archive::is_loading::value) { rotate_timer = NULL; } //TMPHACK
+        ar & open_time;
+        ar & dont_rotate;
+        ar & print_hook;
+        ar & raw_output;
+        //ar & pub_key; //FIXME
+        if (Archive::is_loading::value) { pub_key = NULL; } //TMPHACK
+        //ar & cipher_ctx; //FIXME
+        if (Archive::is_loading::value) { cipher_ctx = NULL; } //TMPHACK
+
+        // Special handling of cipher_buffer
+        ar & cipher_size;
+        if (!Archive::is_loading::value)
+        { 
+            if (cipher_size > 0)
+            { 
+                ar & boost::serialization::make_binary_object(cipher_buffer,
+                        cipher_size); 
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (cipher_size > 0)
+            {
+                cipher_buffer = new u_char[cipher_size];
+                ar & boost::serialization::make_binary_object(cipher_buffer,
+                       cipher_size);
+            }
+            else
+            { cipher_buffer = NULL; }
+        }
+    }
+template void BroFile::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BroFile::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/File.h bro-2.1-sdmbn/src/File.h
--- bro-2.1/src/File.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/File.h	2014-02-17 17:20:06.000000003 -0600
@@ -7,6 +7,7 @@
 #include "util.h"
 #include "Obj.h"
 #include "Attr.h"
+#include <boost/serialization/access.hpp>
 
 # ifdef NEED_KRB5_H
 #  include <krb5.h>
@@ -159,7 +160,11 @@
 
 	static const int MIN_BUFFER_SIZE = 1024;
 	unsigned char* cipher_buffer;
+    int cipher_size;
 
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/FTP.cc bro-2.1-sdmbn/src/FTP.cc
--- bro-2.1/src/FTP.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/FTP.cc	2014-02-17 17:20:06.000000003 -0600
@@ -8,6 +8,9 @@
 #include "FTP.h"
 #include "NVT.h"
 #include "Event.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 FTP_Analyzer::FTP_Analyzer(Connection* conn)
 : TCP_ApplicationAnalyzer(AnalyzerTag::FTP, conn)
@@ -166,3 +169,21 @@
 	ConnectionEvent(f, vl);
 	}
 
+BOOST_CLASS_EXPORT_GUID(FTP_Analyzer,"FTP_Analyzer")
+template<class Archive>
+void FTP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer 
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & nvt_orig;
+        ar & nvt_resp;
+        ar & pending_reply;
+        ar & auth_requested;
+    }
+template void FTP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void FTP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/FTP.h bro-2.1-sdmbn/src/FTP.h
--- bro-2.1/src/FTP.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/FTP.h	2014-02-17 17:20:06.000000003 -0600
@@ -5,6 +5,7 @@
 
 #include "NVT.h"
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
 
 class FTP_Analyzer : public TCP_ApplicationAnalyzer {
 public:
@@ -28,6 +29,10 @@
 	NVT_Analyzer* nvt_resp;
 	uint32 pending_reply;	// code associated with multi-line reply, or 0
 	string auth_requested;	// AUTH method requested
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/Hash.cc bro-2.1-sdmbn/src/Hash.cc
--- bro-2.1/src/Hash.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Hash.cc	2014-02-17 17:20:06.000000003 -0600
@@ -18,6 +18,10 @@
 #include "config.h"
 
 #include "Hash.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
 
 #include "H3.h"
 const H3<hash_t, UHASH_KEY_SIZE>* h3;
@@ -36,6 +40,7 @@
 	size = sizeof(i);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_INT;
 	}
 
 HashKey::HashKey(bro_uint_t u)
@@ -45,6 +50,7 @@
 	size = sizeof(u);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_INT;
 	}
 
 HashKey::HashKey(uint32 u)
@@ -54,6 +60,7 @@
 	size = sizeof(u);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_UINT;
 	}
 
 HashKey::HashKey(const uint32 u[], int n)
@@ -62,6 +69,7 @@
 	key = (void*) u;
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(double d)
@@ -76,6 +84,7 @@
 	size = sizeof(d);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_DOUBLE;
 	}
 
 HashKey::HashKey(const void* p)
@@ -85,6 +94,7 @@
 	size = sizeof(p);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_PTR;
 	}
 
 HashKey::HashKey(const char* s)
@@ -93,6 +103,7 @@
 	key = (void*) s;
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(const BroString* s)
@@ -101,6 +112,7 @@
 	key = (void*) s->Bytes();
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(int copy_key, void* arg_key, int arg_size)
@@ -117,6 +129,7 @@
 		key = arg_key;
 
 	hash = HashBytes(key, size);
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(const void* arg_key, int arg_size, hash_t arg_hash)
@@ -125,6 +138,7 @@
 	hash = arg_hash;
 	key = CopyKey(arg_key, size);
 	is_our_dynamic = 1;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(const void* arg_key, int arg_size, hash_t arg_hash,
@@ -134,6 +148,7 @@
 	hash = arg_hash;
 	key = const_cast<void*>(arg_key);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(const void* bytes, int arg_size)
@@ -142,6 +157,7 @@
 	key = CopyKey(bytes, size);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 1;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 void* HashKey::TakeKey()
@@ -175,3 +191,72 @@
 	hmac_md5(size, (const unsigned char*) bytes, (unsigned char*) digest);
 	return digest[0];
 	}
+
+BOOST_CLASS_EXPORT_GUID(HashKey,"HashKey")
+template<class Archive>
+void HashKey::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & size;
+        ar & type;
+
+        // Special handling of void * pointer to key
+        if (!Archive::is_loading::value)
+        {
+            switch(type)
+            {
+            case HASH_KEY_TYPE_INT:
+                ar & key_u.i;
+                break;
+            case HASH_KEY_TYPE_UINT:
+                ar & key_u.u32;
+                break;
+            case HASH_KEY_TYPE_DOUBLE:
+                ar & key_u.d;
+                break;
+            case HASH_KEY_TYPE_PTR:
+            case HASH_KEY_TYPE_NONE:
+                char *ptr = (char *)key;
+                ar & boost::serialization::make_binary_object(ptr, size);
+                break;
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            switch(type)
+            {
+            case HASH_KEY_TYPE_INT:
+                ar & key_u.i;
+                key = (void*) &key_u;
+                break;
+            case HASH_KEY_TYPE_UINT:
+                ar & key_u.u32;
+                key = (void*) &key_u;
+                break;
+            case HASH_KEY_TYPE_DOUBLE:
+                ar & key_u.d;
+                key = (void*) &key_u;
+                break;
+            case HASH_KEY_TYPE_PTR:
+            case HASH_KEY_TYPE_NONE:
+                char *ptr = new char[size];
+                is_our_dynamic = true; // Force deallocation when destroyed
+                ar & boost::serialization::make_binary_object(ptr, size);
+                if (HASH_KEY_TYPE_PTR == type)
+                { 
+                    key_u.p = (void *)ptr; 
+                    key = (void*) &key_u;
+                }
+                else if (HASH_KEY_TYPE_NONE == type)
+                { key = (void *)ptr; }
+                break;
+            }
+        }
+        
+        ar & hash;
+    }
+template void HashKey::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void HashKey::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/Hash.h bro-2.1-sdmbn/src/Hash.h
--- bro-2.1/src/Hash.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Hash.h	2014-02-17 17:20:06.000000003 -0600
@@ -7,6 +7,8 @@
 
 #include "BroString.h"
 
+#include <boost/serialization/access.hpp>
+
 #define UHASH_KEY_SIZE 36
 
 typedef uint64 hash_t;
@@ -18,6 +20,14 @@
 #define NUM_HASH_KEYS (int(HASH_KEY_STRING) + 1)
 } HashKeyTag;
 
+typedef enum {
+    HASH_KEY_TYPE_INT,
+    HASH_KEY_TYPE_UINT,
+    HASH_KEY_TYPE_DOUBLE,
+    HASH_KEY_TYPE_PTR,
+    HASH_KEY_TYPE_NONE
+} HashKeyType;
+
 class HashKey {
 public:
 	HashKey(bro_int_t i);
@@ -82,6 +92,14 @@
 	void* key;
 	int is_our_dynamic;
 	int size, hash;
+
+    HashKeyType type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    HashKey() {}; // Dummy default constructor for serialization
 };
 
 extern void init_hash_function();
diff -urN bro-2.1/src/HTTP.cc bro-2.1-sdmbn/src/HTTP.cc
--- bro-2.1/src/HTTP.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/HTTP.cc	2014-02-17 17:20:06.000000003 -0600
@@ -12,6 +12,11 @@
 #include "HTTP.h"
 #include "Event.h"
 #include "MIME.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/vector.hpp>
+#include "SDMBNlocal.h"
 
 const bool DEBUG_http = false;
 
@@ -462,6 +467,32 @@
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(HTTP_Entity,"HTTP_Entity")
+template<class Archive>
+void HTTP_Entity::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:HTTP_Entity:%d\n",__FILE__,__LINE__);
+        // Serialize MIME_Entity
+        ar & boost::serialization::base_object<MIME_Entity>(*this);
+
+        ar & http_message;
+        ar & chunked_transfer_state;
+        ar & content_length;
+        ar & expect_data_length;
+        ar & expect_body;
+        ar & body_length;
+        ar & header_length;
+        ar & deliver_body;
+        ar & encoding;
+        ar & zip;
+    }
+template void HTTP_Entity::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void HTTP_Entity::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 HTTP_Message::HTTP_Message(HTTP_Analyzer* arg_analyzer,
 				ContentLine_Analyzer* arg_cl, bool arg_is_orig,
 				int expect_body, int64_t init_header_length)
@@ -475,6 +506,8 @@
 	top_level = new HTTP_Entity(this, 0, expect_body);
 	BeginEntity(top_level);
 
+    buffer_offset = 0;
+    buffer_size = 0;
 	data_buffer = 0;
 	total_buffer_size = 0;
 
@@ -704,7 +737,7 @@
 	{
 	if ( http_entity_data )
 		{
-		const BroString* entity_data = 0;
+		BroString* entity_data = 0;
 
 		if ( data_buffer && buffer_offset > 0 )
 			{
@@ -786,6 +819,43 @@
 	analyzer->Weird(msg);
 	}
 
+
+BOOST_CLASS_EXPORT_GUID(HTTP_Message,"HTTP_Message")
+template<class Archive>
+void HTTP_Message::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:HTTP_Message:%d\n",__FILE__,__LINE__);
+
+        // (De)serialize buffers first, otherwise we run into problems 
+        // deserializing data_buf_data in MIME_Entity due to circular
+        // dependencies between HTTP_Message, MIME_Message, HTTP_Entity, and
+        // MIME_Entit.
+        ar & buffers;
+        ar & data_buffer;
+
+        // Serialize MIME_Message
+        ar & boost::serialization::base_object<MIME_Message>(*this);
+
+        ar & analyzer;
+        ar & content_line;
+        //ar & buffers;
+        ar & total_buffer_size;
+        ar & buffer_offset;
+        ar & buffer_size;
+        //ar & data_buffer;
+        ar & start_time;
+        ar & body_length;
+        ar & header_length;
+        ar & content_gap_length;
+        ar & current_entity;
+    }
+template void HTTP_Message::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void HTTP_Message::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 HTTP_Analyzer::HTTP_Analyzer(Connection* conn)
 	: TCP_ApplicationAnalyzer(AnalyzerTag::HTTP, conn)
 	{
@@ -800,7 +870,8 @@
 	reply_state = EXPECT_REPLY_LINE;
 
 	request_ongoing = 0;
-	request_method = request_URI = 0;
+	request_method = 0;
+    request_URI = 0;
 	unescaped_URI = 0;
 
 	reply_ongoing = 0;
@@ -1338,7 +1409,9 @@
 	Unref(unescaped_URI);
 	Unref(request_URI);
 
-	request_method = request_URI = unescaped_URI = 0;
+	request_method = 0;
+    request_URI = 0;
+    unescaped_URI = 0;
 
 	num_request_lines = 0;
 
@@ -1713,6 +1786,43 @@
 		msg->SkipEntityData();
 	}
 
+BOOST_CLASS_EXPORT_GUID(HTTP_Analyzer,"HTTP_Analyzer")
+template<class Archive>
+void HTTP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer 
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & request_state;
+        ar & reply_state;
+        ar & num_requests;
+        ar & num_replies;
+        ar & num_request_lines;
+        ar & num_reply_lines;
+        ar & request_version;
+        ar & reply_version;
+        ar & keep_alive;
+        ar & connection_close;
+        ar & request_ongoing;
+        ar & reply_ongoing;
+        ar & request_method;
+        ar & request_URI;
+        ar & unescaped_URI;
+        //ar & unanswered_requests; //FIXME
+        ar & reply_code;
+        ar & reply_reason_phrase;
+        ar & content_line_orig;
+        ar & content_line_resp;
+        ar & request_message;
+        ar & reply_message;
+    }
+template void HTTP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void HTTP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 int is_reserved_URI_char(unsigned char ch)
 	{ // see RFC 2396 (definition of URI)
 	return strchr(";/?:@&=+$,", ch) != 0;
diff -urN bro-2.1/src/HTTP.h bro-2.1-sdmbn/src/HTTP.h
--- bro-2.1/src/HTTP.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/HTTP.h	2014-02-17 17:20:06.000000003 -0600
@@ -9,6 +9,7 @@
 #include "binpac_bro.h"
 #include "ZIP.h"
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 enum CHUNKED_TRANSFER_STATE {
 	NON_CHUNKED_TRANSFER,
@@ -20,6 +21,8 @@
 	EXPECT_NOTHING,
 };
 
+typedef enum { IDENTITY, GZIP, COMPRESS, DEFLATE } HTTPEncoding;
+
 class HTTP_Entity;
 class HTTP_Message;
 class HTTP_Analyzer;
@@ -53,7 +56,7 @@
 	int64_t body_length;
 	int64_t header_length;
 	int deliver_body;
-	enum { IDENTITY, GZIP, COMPRESS, DEFLATE } encoding;
+	HTTPEncoding encoding;
 	ZIP_Analyzer* zip;
 
 	MIME_Entity* NewChildEntity() { return new HTTP_Entity(http_message, this, 1); }
@@ -67,6 +70,12 @@
 
 	void SubmitHeader(MIME_Header* h);
 	void SubmitAllHeaders();
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    HTTP_Entity() {}; // Dummy default constructor for serialization
 };
 
 enum {
@@ -115,12 +124,33 @@
 	void Weird(const char* msg);
 	bool IsOrig()	{ return is_orig; }
 
+    int GetBufferDiff(char *buf) 
+    { 
+        if (0 == data_buffer)
+            {
+            if (0 == buffers.size())
+            { return -1; }
+            return buf - (char *)buffers.back()->Bytes();
+            }
+        return buf - (char *)data_buffer->Bytes();
+    }
+    char* GetBuffer(int diff)
+    { 
+        if (0 == data_buffer)
+            {
+            if (0 == buffers.size())
+            { return NULL; }
+            return (char *)buffers.back()->Bytes() + diff;
+            }
+        return (char *)data_buffer->Bytes() + diff; 
+    }
+
 protected:
 	HTTP_Analyzer* analyzer;
 	ContentLine_Analyzer* content_line;
 	bool is_orig;
 
-	vector<const BroString*> buffers;
+	vector<BroString*> buffers;
 
 	// Controls the total buffer size within http_entity_data_delivery_size.
 	int total_buffer_size;
@@ -143,6 +173,25 @@
 	void DeliverEntityData();
 
 	Val* BuildMessageStat(const int interrupted, const char* msg);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    HTTP_Message() { 
+        analyzer = 0;
+        content_line = 0;
+        is_orig = 0;
+        total_buffer_size = 0;
+        buffer_offset = 0;
+        buffer_size = 0;
+    //    data_buffer = 0; 
+        start_time = 0;
+        body_length = 0;
+        header_length = 0;
+        content_gap_length = 0;
+        current_entity = 0; 
+    }; // Dummy default constructor for serialization
 };
 
 class HTTP_Analyzer : public TCP_ApplicationAnalyzer {
@@ -227,7 +276,7 @@
 	int connection_close;
 	int request_ongoing, reply_ongoing;
 
-	Val* request_method;
+	StringVal* request_method;
 
 	// request_URI is in the original form (may contain '%<hex><hex>'
 	// sequences).
@@ -246,6 +295,12 @@
 
 	HTTP_Message* request_message;
 	HTTP_Message* reply_message;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    HTTP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 extern int is_reserved_URI_char(unsigned char ch);
diff -urN bro-2.1/src/ICMP.cc bro-2.1-sdmbn/src/ICMP.cc
--- bro-2.1/src/ICMP.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ICMP.cc	2014-02-17 17:20:06.000000003 -0600
@@ -10,6 +10,9 @@
 #include "ICMP.h"
 
 #include <netinet/icmp6.h>
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 ICMP_Analyzer::ICMP_Analyzer(Connection* c)
 : TransportLayerAnalyzer(AnalyzerTag::ICMP, c)
@@ -835,6 +838,29 @@
 	return vv;
 	}
 
+BOOST_CLASS_EXPORT_GUID(ICMP_Analyzer,"ICMP_Analyzer")
+template<class Archive>
+void ICMP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        printf("%s:ICMP_Analyzer:%d",__FILE__,__LINE__);
+
+        // Serialize TransportLayerAnalyzer
+        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this);
+
+        ar & icmp_conn_val;
+        ar & type;
+        ar & code;
+        ar & request_len;
+        ar & reply_len;
+//        //ar & matcher_state; //FIXME
+    }
+template void ICMP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ICMP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 int ICMP4_counterpart(int icmp_type, int icmp_code, bool& is_one_way)
 	{
 	is_one_way = false;
diff -urN bro-2.1/src/ICMP.h bro-2.1-sdmbn/src/ICMP.h
--- bro-2.1/src/ICMP.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ICMP.h	2014-02-17 17:20:06.000000003 -0600
@@ -4,6 +4,7 @@
 #define icmp_h
 
 #include "Analyzer.h"
+#include <boost/serialization/access.hpp>
 
 typedef enum {
 	ICMP_INACTIVE,	// no packet seen
@@ -87,6 +88,10 @@
 
 private:
 	void UpdateEndpointVal(RecordVal* endp, int is_orig);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // Returns the counterpart type to the given type (e.g., the counterpart
diff -urN bro-2.1/src/ID.cc bro-2.1-sdmbn/src/ID.cc
--- bro-2.1/src/ID.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ID.cc	2014-02-17 17:20:06.000000003 -0600
@@ -14,6 +14,11 @@
 #include "PersistenceSerializer.h"
 #include "Scope.h"
 #include "Traverse.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 ID::ID(const char* arg_name, IDScope arg_scope, bool arg_is_export)
 	{
@@ -767,3 +772,59 @@
 	}
 #endif
 
+BOOST_CLASS_EXPORT_GUID(ID,"ID")
+template<class Archive>
+void ID::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:ID:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        // Special handling of name
+        int name_len; 
+        if (!Archive::is_loading::value)
+        {
+            if (NULL == name)
+            { name_len = 0; }
+            else
+            { name_len = strlen(name) + 1; }
+        }
+        ar & name_len;
+        if (!Archive::is_loading::value)
+        { 
+            if (name_len > 0)
+            { 
+                ar & boost::serialization::make_binary_object((void *)name,
+                        name_len); 
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (name_len > 0)
+            {
+                name = new char[name_len];
+                ar & boost::serialization::make_binary_object(
+                        const_cast<char * &>(name), name_len);
+            }
+            else
+            { name = NULL; }
+        }
+
+        ar & scope;
+        ar & is_export;
+        ar & type;
+        ar & is_const;
+        ar & is_enum_const;
+        ar & is_type;
+        ar & offset;
+        ar & val;
+        ar & attrs;
+        ar & infer_return_type;
+        ar & weak_ref;
+    }
+template void ID::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ID::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/ID.h bro-2.1-sdmbn/src/ID.h
--- bro-2.1/src/ID.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ID.h	2014-02-17 17:20:06.000000003 -0600
@@ -8,6 +8,7 @@
 #include "StateAccess.h"
 #include "TraverseTypes.h"
 #include <string>
+#include <boost/serialization/access.hpp>
 
 class Val;
 class SerialInfo;
@@ -118,6 +119,10 @@
 
 	bool infer_return_type;
 	bool weak_ref;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/IPAddr.cc bro-2.1-sdmbn/src/IPAddr.cc
--- bro-2.1/src/IPAddr.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/IPAddr.cc	2014-02-17 17:20:06.000000003 -0600
@@ -7,6 +7,9 @@
 #include "Conn.h"
 #include "DPM.h"
 #include "bro_inet_ntop.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 const uint8_t IPAddr::v4_mapped_prefix[12] = { 0, 0, 0, 0,
                                                0, 0, 0, 0,
@@ -230,6 +233,19 @@
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(IPAddr,"IPAddr")
+template<class Archive>
+void IPAddr::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & in6.s6_addr;
+    }
+template void IPAddr::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void IPAddr::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 IPPrefix::IPPrefix(const in4_addr& in4, uint8_t length)
 	: prefix(in4), length(96 + length)
 	{
@@ -284,3 +300,16 @@
 	return prefix.AsString() +"/" + l;
 	}
 
+BOOST_CLASS_EXPORT_GUID(IPPrefix,"IPPrefix")
+template<class Archive>
+void IPPrefix::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & prefix;
+        ar & length; 
+    }
+template void IPPrefix::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void IPPrefix::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/IPAddr.h bro-2.1-sdmbn/src/IPAddr.h
--- bro-2.1/src/IPAddr.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/IPAddr.h	2014-02-17 17:20:06.000000003 -0600
@@ -12,6 +12,7 @@
 #include "util.h"
 #include "Type.h"
 #include "threading/SerialTypes.h"
+#include <boost/serialization/access.hpp>
 
 struct ConnID;
 class ExpectedConn;
@@ -351,6 +352,8 @@
 	friend HashKey* BuildExpectedConnHashKey(const ExpectedConn& c);
 
 	unsigned int MemoryAllocation() const { return padded_sizeof(*this); }
+	
+    in6_addr in6; // IPv6 or v4-to-v6-mapped address
 
 private:
 	friend class IPPrefix;
@@ -363,9 +366,10 @@
 	 */
 	void Init(const std::string& s);
 
-	in6_addr in6; // IPv6 or v4-to-v6-mapped address
-
 	static const uint8_t v4_mapped_prefix[12]; // top 96 bits of v4-mapped-addr
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 inline IPAddr::IPAddr(Family family, const uint32_t* bytes, ByteOrder order)
@@ -603,6 +607,10 @@
 private:
 	IPAddr prefix;	// We store it as an address with the non-prefix bits masked out via Mask().
 	uint8_t length;	// The bit length of the prefix relative to full IPv6 addr.
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/List.cc bro-2.1-sdmbn/src/List.cc
--- bro-2.1/src/List.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/List.cc	2014-02-17 17:20:06.000000003 -0600
@@ -5,6 +5,10 @@
 
 #include "List.h"
 #include "util.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 static const int DEFAULT_CHUNK_SIZE = 10;
 
@@ -230,3 +234,23 @@
 
 	return (i == length()) ? -1 : i;
 	}
+
+BOOST_CLASS_EXPORT_GUID(BaseList,"BaseList")
+template<class Archive>
+void BaseList::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BaseList:%d",__FILE__,__LINE__);
+
+        // Do not serialize ent -- this is handled by classes which inherit 
+        // from BaseList 
+
+        ar & chunk_size;
+        ar & max_entries;
+        ar & num_entries;
+    }
+template void BaseList::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BaseList::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/List.h bro-2.1-sdmbn/src/List.h
--- bro-2.1/src/List.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/List.h	2014-02-17 17:20:06.000000003 -0600
@@ -22,6 +22,7 @@
 
 #include <stdarg.h>
 #include "util.h"
+#include <boost/serialization/access.hpp>
 
 typedef void* ent;
 typedef int (*list_cmp_func)(const void* v1, const void* v2);
@@ -82,6 +83,10 @@
 	int chunk_size;		// increase size by this amount when necessary
 	int max_entries;
 	int num_entries;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 	};
 
 
@@ -178,7 +183,38 @@
 	      ep = va_arg(ap,type*) )					\
 		append(ep);						\
 	resize();							\
-	}
+	}   \
+\
+BOOST_CLASS_EXPORT_GUID(PList(type),"PList(type)")  \
+template<class Archive> \
+void PList(type)::serialize(Archive & ar, const unsigned int version)   \
+    {   \
+        SERIALIZE_PRINT("%s:PList(type):%d",__FILE__,__LINE__); \
+        ar & boost::serialization::base_object<BaseList>(*this);    \
+        if (!Archive::is_loading::value)    \
+        {   \
+            for (int i = 0; i < num_entries; i++)   \
+            {   \
+                type *item = (type *)(entry[i]);    \
+                ar & item;  \
+            }   \
+        }   \
+        if (Archive::is_loading::value) \
+        {   \
+            for (int i = 0; i < num_entries; i++)   \
+            {   \
+                type *item; \
+                ar & item;  \
+                enttry[i] = (ent)(item);    \
+            }   \
+        }   \
+    }   \
+template void BaseList::serialize<boost::archive::text_oarchive>(   \
+        boost::archive::text_oarchive & ar,     \
+        const unsigned int file_version);   \
+template void BaseList::serialize<boost::archive::text_iarchive>(   \
+        boost::archive::text_iarchive & ar,     \
+        const unsigned int file_version);
 
 
 #define declare(metatype,type) metatype ## declare (type)
diff -urN bro-2.1/src/main.cc bro-2.1-sdmbn/src/main.cc
--- bro-2.1/src/main.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/main.cc	2014-04-15 13:53:57.000000003 -0500
@@ -59,6 +59,16 @@
 #include "logging/writers/Ascii.h"
 
 #include "binpac_bro.h"
+extern "C" {
+#include <SDMBN.h>
+}
+#include "SDMBNlocal.h"
+#include <fstream>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/archive/text_oarchive.hpp>
+
+#define STATE_TMP_OUTFILE "stateout.tmp"
+#define STATE_TMP_INFILE "statein.tmp"
 
 Brofiler brofiler;
 
@@ -339,6 +349,8 @@
 	delete reporter;
 
 	reporter = 0;
+
+    sdmbn_cleanup();
 	}
 
 void termination_signal()
@@ -494,13 +506,15 @@
 	opterr = 0;
 
 	char opts[256];
-	safe_strncpy(opts, "B:D:e:f:I:i:K:l:n:p:R:r:s:T:t:U:w:x:X:y:Y:z:CFGLOPSWbdghvZ",
+	safe_strncpy(opts, "B:D:e:f:I:i:K:l:n:p:R:r:s:T:t:U:w:x:X:y:Y:z:CFGLOPSWbdghvZJ:",
 		     sizeof(opts));
 
 #ifdef USE_PERFTOOLS_DEBUG
 	strncat(opts, "mM", 2);
 #endif
 
+    char *device = NULL;
+
 	int op;
 	while ( (op = getopt_long(argc, argv, opts, long_opts, &long_optsind)) != EOF )
 		switch ( op ) {
@@ -527,6 +541,7 @@
 
 		case 'i':
 			interfaces.append(optarg);
+            device = optarg;
 			break;
 
 		case 'p':
@@ -701,6 +716,15 @@
 	atexit(atexit_handler);
 	set_processing_status("INITIALIZING", "main");
 
+    // Initialize SDMBN
+    SDMBNLocals locals;
+    bzero(&locals, sizeof(locals));
+    locals.get_perflow = &local_get_perflow;
+    locals.put_perflow = &local_put_perflow;
+    locals.device = device;
+    sdmbn_init(&locals);
+		
+
 	bro_start_time = current_time(true);
 
 	reporter = new Reporter();
@@ -1094,3 +1118,249 @@
 
 	return 0;
 	}
+
+static Connection *sdmbn_boost_decode(char *state)
+{	
+	long state_size = strlen(state);
+    FILE *file;
+    file = fopen(STATE_TMP_INFILE,"w+b");
+    if (!file) 
+    { 
+        ERROR_PRINT("Could not open serialization file");
+        return NULL;
+    }
+
+    if (int result = fwrite(state, state_size, 1, file) != 1)
+    { 
+        ERROR_PRINT("Could not write serialized state: %d", result);
+        fclose(file);
+        return NULL;
+    }
+    fclose(file);
+
+    // Unserialize connection from temporary archive file
+    Connection *conn;
+    std::ifstream filestream(STATE_TMP_INFILE);
+    {
+        boost::archive::text_iarchive ar(filestream);
+        try
+        {
+            ar & conn;
+        }
+        catch(const std::exception & ex)
+        {
+            ERROR_PRINT("Exception during unserialize: %s",ex.what());
+        }
+    }
+    filestream.close();
+	return conn;
+}
+
+int local_put_perflow(int hashkey, PerflowKey *key, char *state)
+{
+	if (NULL == key || NULL == state)
+	{ return -1; }
+	Connection *conn = sdmbn_boost_decode(state);
+	conn->setGetOpId(0);
+	if (NULL == conn)
+    {
+            ERROR_PRINT("Failed to parse connection");
+            return 0;
+    }
+	sessions->Insert(conn);
+	INFO_PRINT("Connection inserted");
+    return 1;
+}
+
+static char *sdmbn_boost_encode(Connection *conn)
+{
+    // Serialize connection to temporary archive file
+//    try
+//    {
+        std::ofstream filestream(STATE_TMP_OUTFILE);
+        {
+            boost::archive::text_oarchive ar(filestream);
+            ar & conn;
+        }
+        filestream.close();
+//    }
+//    catch(const std::exception & ex)
+//    catch(const boost::archive::archive_exception & ex)
+//    {
+//        ERROR_PRINT("Exception during serialize: %s",ex.what());
+//        assert(false);
+//    }
+
+    // Read serialized connection from temporary archive file
+    FILE *file;
+    long state_size;
+    char *state;
+    file = fopen(STATE_TMP_OUTFILE,"rb");
+    if (!file) 
+    { 
+        ERROR_PRINT("Could not open serialization file");
+        return NULL;
+    }
+    fseek(file,0L,SEEK_END);
+    state_size = ftell(file);
+    rewind(file);
+    state = (char *)malloc(state_size+1);
+    if (!state)
+    { 
+        ERROR_PRINT("Could not allocate space for serialized state");
+        fclose(file);
+        return NULL;
+    }
+    if (int result = fread(state, state_size, 1, file) != 1)
+    { 
+        ERROR_PRINT("Could not read serialized state: %d", result);
+        fclose(file);
+        free(state);
+        return NULL;
+    }
+    fclose(file);
+    state[state_size] = '\0';
+    return state;
+}
+
+static int handle_get_proto(PerflowKey *key, int proto, int id, int raiseEvents)
+{
+	// Match based on nw_proto
+    Dictionary *d = NULL;
+    switch(proto)
+    {
+    case IPPROTO_TCP:
+        d = &(sessions->tcp_conns);
+        break;
+    case IPPROTO_UDP:
+        d = &(sessions->udp_conns);
+        break;
+    case IPPROTO_ICMP:
+    case IPPROTO_ICMPV6:
+        d = &(sessions->icmp_conns);
+        break;
+    case IPPROTO_IPV4:
+    case IPPROTO_IPV6:
+    default:
+        ERROR_PRINT("Cannot handle proto %d", proto);
+        return 0;
+    }
+	
+	IterCookie *cookie = d->InitForIteration();
+    d->MakeRobustCookie(cookie);
+    int count = 0;
+	while (1)
+    {
+		HashKey *hashkey;
+        Connection *conn = (Connection *)(d->NextEntry(hashkey, 
+                    cookie, 0));
+        if (NULL == conn)
+        { break; }
+
+        if (conn->HasMoved())
+        { continue; }
+        
+        // Check tp_src
+        if (!(key->wildcards & WILDCARD_TP_SRC) &&
+                !(conn->OrigPort() == key->tp_src
+                    || (key->tp_flip && conn->RespPort() == key->tp_src)))
+        { continue; }
+
+        // Check tp_dst
+        if (!(key->wildcards & WILDCARD_TP_DST) &&
+                !(conn->RespPort() == key->tp_dst
+                    || (key->tp_flip && conn->OrigPort() == key->tp_dst)))
+        { continue; }
+
+        int nw_src_mask = 0xFFFFFFFF;
+        if (!(key->wildcards & WILDCARD_NW_SRC_MASK))
+        { nw_src_mask = nw_src_mask << (32 - key->nw_src_mask); }
+
+        // Check nw_src
+        if (!(key->wildcards & WILDCARD_NW_SRC) &&
+                (nw_src_mask & conn->OrigAddr().in6.s6_addr32[0]) 
+                    != key->nw_src)
+        { continue; }
+
+        int nw_dst_mask = 0xFFFFFFFF;
+        if (!(key->wildcards & WILDCARD_NW_DST_MASK))
+        { nw_dst_mask = nw_dst_mask << (32 - key->nw_dst_mask); }
+
+        // Check nw_dst
+        if (!(key->wildcards & WILDCARD_NW_DST) &&
+                (nw_dst_mask & conn->RespAddr().in6.s6_addr32[0]) 
+                    != key->nw_dst)
+        { continue; }
+
+		// treat the matched connections
+
+        // send conn now 
+		// Create supporting field from Connection object
+        pthread_mutex_lock(&conn->lock);
+        char *state = sdmbn_boost_encode(conn);
+        conn->setGetOpId(id);
+	if (raiseEvents)
+        	conn->Moved();
+
+        if (NULL == state)
+        {
+            ERROR_PRINT("Failed to serialize connection");
+            continue;
+        }
+
+        // Save hash for use later
+        int hash = conn->Key()->Hash();
+
+        // Get the UID
+        // char uid[20];
+        // uitoa_n(conn->GetUID(), uid, sizeof(uid), 62);
+
+        // Create Perflow key field from connection identification information
+        PerflowKey connkey;
+        connkey.wildcards = WILDCARD_DL_TYPE;
+        in_addr tmpaddr;
+        conn->OrigAddr().CopyIPv4(&tmpaddr);
+        connkey.nw_src = tmpaddr.s_addr;
+        conn->RespAddr().CopyIPv4(&tmpaddr);
+        connkey.nw_dst = tmpaddr.s_addr;
+        connkey.tp_src = conn->OrigPort();
+        connkey.tp_dst = conn->RespPort();
+        switch (conn->ConnTransport())
+        {
+        case TRANSPORT_TCP:
+            connkey.nw_proto = IPPROTO_TCP;
+            break;
+        case TRANSPORT_UDP:
+            connkey.nw_proto = IPPROTO_UDP;
+            break;
+        case TRANSPORT_ICMP:
+            connkey.nw_proto = IPPROTO_ICMP;
+            break;
+        default:
+            connkey.wildcards |= WILDCARD_NW_PROTO;
+            break;
+        }
+        pthread_mutex_unlock(&conn->lock);
+		int result = sdmbn_send_perflow(id, &connkey, state, hash, count);
+		count++;
+		free(state);
+	}
+	return count;
+}
+
+int local_get_perflow(PerflowKey *key, int id, int raiseEvents, SDMBNExt *unused)
+{
+	if (NULL == key)
+	{ return -1; }
+
+	int count = 0;
+    if (0 == key->nw_proto)
+    {
+        count += handle_get_proto(key, IPPROTO_TCP, id, raiseEvents);
+        count += handle_get_proto(key, IPPROTO_UDP, id, raiseEvents);
+        count += handle_get_proto(key, IPPROTO_ICMP, id, raiseEvents);
+    }
+    else
+    { count = handle_get_proto(key, key->nw_proto, id, raiseEvents); }
+	return count;
+}
diff -urN bro-2.1/src/MIME.cc bro-2.1-sdmbn/src/MIME.cc
--- bro-2.1/src/MIME.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/MIME.cc	2014-02-17 17:20:07.000000003 -0600
@@ -5,6 +5,11 @@
 #include "Event.h"
 #include "Reporter.h"
 #include "digest.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/vector.hpp>
+#include <boost/serialization/binary_object.hpp>
 
 // Here are a few things to do:
 //
@@ -157,6 +162,19 @@
 	return line;
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Multiline,"MIME_Multiline")
+template<class Archive>
+void MIME_Multiline::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & buffer;
+        ar & line; 
+    }
+template void MIME_Multiline::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Multiline::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 MIME_Header::MIME_Header(MIME_Multiline* hl)
 	{
@@ -225,6 +243,23 @@
 	return rest_value;
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Header,"MIME_Header")
+template<class Archive>
+void MIME_Header::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & lines;
+        //ar & name; //FIXME
+        //ar & value; //FIXME
+        //ar & value_token; //FIXME
+        //ar & rest_value; //FIXME
+    }
+template void MIME_Header::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Header::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 MIME_Entity::MIME_Entity(MIME_Message* output_message, MIME_Entity* parent_entity)
 	{
 	init();
@@ -939,6 +974,56 @@
 #endif
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Entity,"MIME_Entity")
+template<class Archive>
+void MIME_Entity::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & in_header;
+        ar & end_of_data;
+        ar & current_header_line; 
+        ar & current_field_type;
+        ar & need_to_parse_parameters;
+        ar & content_type_str;
+        ar & content_subtype_str;
+        ar & content_encoding_str;
+        ar & multipart_boundary;
+        ar & content_type;
+        ar & content_subtype;
+        ar & content_encoding;
+        ar & headers;
+        ar & parent;
+        ar & current_child_entity;
+        ar & base64_decoder;
+        ar & data_buf_length;
+        ar & data_buf_offset;
+        ar & message;
+
+        // Special handling of data_buf_data
+        int diff;
+        if (!Archive::is_loading::value)
+        { 
+            if (0 == data_buf_data || 0 == message)
+            { diff = -1; }
+            else
+            { diff = message->GetBufferDiff(data_buf_data); }
+        }
+        ar & diff;
+        if (Archive::is_loading::value)
+        {
+            if (diff < 0)
+            { data_buf_data = 0; }
+            else
+            { data_buf_data = message->GetBuffer(diff); }
+        }
+
+    }
+template void MIME_Entity::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Entity::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 RecordVal* MIME_Message::BuildHeaderVal(MIME_Header* h)
 	{
 	RecordVal* header_record = new RecordVal(mime_header_rec);
@@ -966,6 +1051,21 @@
 	return t;
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Message,"MIME_Message")
+template<class Archive>
+void MIME_Message::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & analyzer;
+        ar & top_level;
+        ar & finished;
+    }
+template void MIME_Message::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Message::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 MIME_Mail::MIME_Mail(Analyzer* mail_analyzer, int buf_size)
 : MIME_Message(mail_analyzer)
 	{
@@ -985,7 +1085,7 @@
 		length = max_chunk_length;
 
 	buffer_start = data_start = 0;
-	data_buffer = new BroString(1, new u_char[length+1], length);
+	data_buffer = new BroString(1, new u_char[length+1], length); // FIXME?
 
 	if ( mime_content_hash )
 		{
@@ -1014,7 +1114,7 @@
 		val_list* vl = new val_list;
 		vl->append(analyzer->BuildConnVal());
 		vl->append(new Val(content_hash_length, TYPE_COUNT));
-		vl->append(new StringVal(new BroString(1, digest, 16)));
+		vl->append(new StringVal(new BroString(1, digest, 16))); // FIXME?
 		analyzer->ConnectionEvent(mime_content_hash, vl);
 		}
 
@@ -1193,6 +1293,31 @@
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Mail,"MIME_Mail")
+template<class Archive>
+void MIME_Mail::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize MIME_Message
+        ar & boost::serialization::base_object<MIME_Message>(*this);
+
+        ar & min_overlap_length;
+        ar & max_chunk_length;
+        ar & buffer_start;
+        ar & data_start;
+        ar & buffer_offset;
+        ar & compute_content_hash;
+        ar & content_hash_length;
+        //ar & md5_hash; //FIXME
+        ar & entity_content; 
+        ar & all_content;
+        ar & data_buffer;
+    }
+template void MIME_Mail::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Mail::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 int strcasecmp_n(data_chunk_t s, const char* t)
 	{
diff -urN bro-2.1/src/MIME.h bro-2.1-sdmbn/src/MIME.h
--- bro-2.1/src/MIME.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/MIME.h	2014-02-17 17:20:07.000000003 -0600
@@ -11,6 +11,7 @@
 #include "Base64.h"
 #include "BroString.h"
 #include "Analyzer.h"
+#include <boost/serialization/access.hpp>
 
 // MIME: Multipurpose Internet Mail Extensions
 // Follows RFC 822 & 2822 (Internet Mail), 2045-2049 (MIME)
@@ -57,8 +58,12 @@
 	BroString* get_concatenated_line();
 
 protected:
-	vector<const BroString*> buffer;
+	vector<BroString*> buffer;
 	BroString* line;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class MIME_Header {
@@ -79,6 +84,12 @@
 	data_chunk_t name;
 	data_chunk_t value;
 	data_chunk_t value_token, rest_value;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    MIME_Header() {}; // Dummy default constructor for serialization
 };
 
 
@@ -170,6 +181,33 @@
 	int data_buf_offset;
 
 	MIME_Message* message;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    MIME_Entity() 
+    {
+        in_header = 0;
+        end_of_data = 0;
+        current_header_line = 0;
+        current_field_type = 0;
+        need_to_parse_parameters = 0;
+        content_type_str = 0;
+        content_subtype_str = 0;
+        content_encoding_str = 0;
+        multipart_boundary = 0;
+        content_type = 0;
+        content_subtype = 0;
+        content_encoding = 0;
+        parent = 0;
+        current_child_entity = 0;
+        base64_decoder = 0;
+        data_buf_length = 0;
+        data_buf_data = 0;
+        data_buf_offset = 0;
+        message = 0;
+    }; // Dummy default constructor for serialization
 };
 
 // The reason I separate MIME_Message as an abstract class is to
@@ -214,6 +252,9 @@
 	virtual int RequestBuffer(int* plen, char** pbuf) = 0;
 	virtual void SubmitEvent(int event_type, const char* detail) = 0;
 
+    virtual int GetBufferDiff(char *buf) = 0;
+    virtual char* GetBuffer(int diff) = 0;
+
 protected:
 	Analyzer* analyzer;
 
@@ -222,6 +263,12 @@
 
 	RecordVal* BuildHeaderVal(MIME_Header* h);
 	TableVal* BuildHeaderTable(MIME_HeaderList& hlist);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    MIME_Message() {}; // Dummy default constructor for serialization
 };
 
 class MIME_Mail : public MIME_Message {
@@ -239,6 +286,9 @@
 	void SubmitAllData();
 	void SubmitEvent(int event_type, const char* detail);
 
+    int GetBufferDiff(char *buf) { return (0 == data_buffer ? -1 : buf - (char *)data_buffer->Bytes()); }
+    char* GetBuffer(int diff) { return (char *)data_buffer->Bytes() + diff; }
+
 protected:
 	int min_overlap_length;
 	int max_chunk_length;
@@ -248,10 +298,18 @@
 	int compute_content_hash;
 	int content_hash_length;
 	MD5_CTX md5_hash;
-	vector<const BroString*> entity_content;
-	vector<const BroString*> all_content;
+//	vector<const BroString*> entity_content;
+	vector<BroString*> entity_content;
+//	vector<const BroString*> all_content;
+	vector<BroString*> all_content;
 
 	BroString* data_buffer;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    MIME_Mail() {}; // Dummy default constructor for serialization
 };
 
 
diff -urN bro-2.1/src/NVT.cc bro-2.1-sdmbn/src/NVT.cc
--- bro-2.1/src/NVT.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/NVT.cc	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,9 @@
 #include "NetVar.h"
 #include "Event.h"
 #include "TCP.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 #define IS_3_BYTE_OPTION(c) (c >= 251 && c <= 254)
 
@@ -701,3 +704,28 @@
 	Event(bad_option_termination);
 	}
 
+BOOST_CLASS_EXPORT_GUID(NVT_Analyzer,"NVT_Analyzer")
+template<class Archive>
+void NVT_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize ContentLine_Analyzer
+        ar & boost::serialization::base_object<ContentLine_Analyzer>(*this);
+
+        ar & peer;
+        ar & pending_IAC;
+        ar & IAC_pos;
+        ar & is_suboption;
+        ar & last_was_IAC;
+        ar & binary_mode;
+        ar & encrypting_mode;
+        ar & authentication_has_been_accepted;
+        //ar & auth_name; //FIXME
+        //ar & options; //FIXME
+        ar & num_options;
+    }
+template void NVT_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void NVT_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/NVT.h bro-2.1-sdmbn/src/NVT.h
--- bro-2.1/src/NVT.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/NVT.h	2014-02-17 17:20:07.000000003 -0600
@@ -4,6 +4,7 @@
 #define nvt_h
 
 #include "ContentLine.h"
+#include <boost/serialization/access.hpp>
 
 
 #define TELNET_OPTION_BINARY 0
@@ -168,6 +169,12 @@
 
 	TelnetOption* options[NUM_TELNET_OPTIONS];
 	int num_options;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    NVT_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/Obj.cc bro-2.1-sdmbn/src/Obj.cc
--- bro-2.1/src/Obj.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Obj.cc	2014-02-17 17:20:07.000000003 -0600
@@ -7,6 +7,11 @@
 #include "Obj.h"
 #include "Serializer.h"
 #include "File.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 Location no_location("<no location>", 0, 0, 0, 0);
 Location start_location("<start uninitialized>", 0, 0, 0, 0);
@@ -85,6 +90,74 @@
 		return false;
 	}
 
+BOOST_CLASS_EXPORT_GUID(Location,"Location")
+template<class Archive>
+void Location::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Location:%d",__FILE__,__LINE__);
+        // Serialize SerialObj?
+        //ar & boost::serialization::base_object<>(*this);
+        
+        // Special handling of filename & delete_data
+        int filename_len;
+        if (!Archive::is_loading::value)
+        { filename_len = strlen(filename)+1; }
+        ar & filename_len;
+        if (!Archive::is_loading::value)
+        { 
+            ar & boost::serialization::make_binary_object((void *)filename, 
+                    filename_len); 
+        }
+        if (Archive::is_loading::value)
+        {
+            filename = new char[filename_len];
+            ar & boost::serialization::make_binary_object(
+                    const_cast<char* &>(filename), filename_len);
+            delete_data = true;
+        }
+
+        SERIALIZE_PRINT("\t\tLocation:%d",__LINE__);
+        ar & first_line;
+        ar & last_line;
+        ar & first_column;
+        ar & last_column;
+        ar & timestamp;
+
+        // Special handling of text 
+        int text_len;
+        if (!Archive::is_loading::value)
+        {
+            if (text)
+            { text_len = strlen(text); }
+            else
+            { text_len = 0; }
+        }
+        ar & text_len;
+        if (!Archive::is_loading::value)
+        { 
+            if (text_len > 0)
+            { ar & boost::serialization::make_binary_object(text, text_len); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (text_len > 0)
+            {
+                text = new char[text_len];
+                ar & boost::serialization::make_binary_object(text, text_len);
+            }
+            else
+            { text = NULL; }
+        }
+
+        SERIALIZE_PRINT("\t\tLocation:Done");
+    }
+template void Location::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Location::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 int BroObj::suppress_errors = 0;
 
 BroObj::~BroObj()
@@ -237,6 +310,28 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(BroObj,"BroObj")
+template<class Archive>
+void BroObj::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BroObj:%d",__FILE__,__LINE__);
+        // Serialize SerialObj?
+        //ar & boost::serialization::base_object<>(*this);
+    
+        // Mark object as not in serialization cache
+        if (Archive::is_loading::value) { in_ser_cache = false; }
+
+        ar & location;
+        ar & ref_cnt;
+        SERIALIZE_PRINT("\t\t:BroObj:Done");
+    }
+template void BroObj::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BroObj::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 void print(const BroObj* obj)
 	{
 	static BroFile fstderr(stderr);
diff -urN bro-2.1/src/Obj.h bro-2.1-sdmbn/src/Obj.h
--- bro-2.1/src/Obj.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Obj.h	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,7 @@
 #include "input.h"
 #include "Desc.h"
 #include "SerialObj.h"
+#include <boost/serialization/access.hpp>
 
 class Serializer;
 class SerialInfo;
@@ -61,6 +62,10 @@
 	char* text;
 protected:
 	DECLARE_SERIAL(Location);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #define YYLTYPE yyltype
@@ -186,6 +191,10 @@
 	// If non-zero, do not print runtime errors.  Useful for
 	// speculative evaluation.
 	static int suppress_errors;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // Prints obj to stderr, primarily for debugging.
diff -urN bro-2.1/src/PIA.cc bro-2.1-sdmbn/src/PIA.cc
--- bro-2.1/src/PIA.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/PIA.cc	2014-02-17 17:20:07.000000003 -0600
@@ -1,6 +1,10 @@
 #include "PIA.h"
 #include "RuleMatcher.h"
 #include "TCP_Reassembler.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 PIA::PIA(Analyzer* arg_as_analyzer)
 	{
@@ -129,6 +133,40 @@
 				bol, eol, clear_state);
 	}
 
+BOOST_CLASS_EXPORT_GUID(PIA,"PIA")
+template<class Archive>
+void PIA::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PIA:%d",__FILE__,__LINE__);
+
+        // Serialize RuleMatcherState
+        ar & boost::serialization::base_object<RuleMatcherState>(*this);
+
+        //ar & pkt_buffer.head //FIXME
+        //ar & pkt_buffer.tail //FIXME
+        ar & pkt_buffer.size;
+        ar & pkt_buffer.state;
+
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            if (as_analyzer != NULL)
+            { assert(sdmbn_can_serialize(as_analyzer->GetTag())); }
+        }
+        SERIALIZE_PRINT("PIA:%d",__LINE__);
+        ar & as_analyzer;
+
+        ar & conn;
+        //ar & current_packet; //FIXME
+        SERIALIZE_PRINT("\t\tPIA:Done");
+    }
+template void PIA::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PIA::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 void PIA_UDP::ActivateAnalyzer(AnalyzerTag::Tag tag, const Rule* rule)
 	{
 	if ( pkt_buffer.state == MATCHING_ONLY )
@@ -154,6 +192,25 @@
 	reporter->InternalError("PIA_UDP::Deact not implemented yet");
 	}
 
+BOOST_CLASS_EXPORT_GUID(PIA_UDP,"PIA_UDP")
+template<class Archive>
+void PIA_UDP::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PIA_UDP:%d",__FILE__,__LINE__);
+
+        // Serialize PIA
+        ar & boost::serialization::base_object<PIA>(*this);
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>(*this);
+        SERIALIZE_PRINT("\t\tPIA_UDP:Done");
+    }
+template void PIA_UDP::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PIA_UDP::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 //// TCP PIA
 
 PIA_TCP::~PIA_TCP()
@@ -388,3 +445,29 @@
 			analyzer->NextUndelivered(b->seq, b->len, b->is_orig);
 		}
 	}
+
+BOOST_CLASS_EXPORT_GUID(PIA_TCP,"PIA_TCP")
+template<class Archive>
+void PIA_TCP::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PIA_TCP:%d",__FILE__,__LINE__);
+
+        // Serialize PIA
+        ar & boost::serialization::base_object<PIA>(*this);
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        //ar & stream_buffer.head; //FIXME
+        //ar & stream_buffer.tail; //FIXME
+        SERIALIZE_PRINT("\t\tPIA_TCP:%d",__LINE__);
+        ar & stream_buffer.size;
+        ar & stream_buffer.state;
+        ar & stream_mode;
+        SERIALIZE_PRINT("\t\tPIA_TCP:Done");
+    }
+template void PIA_TCP::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PIA_TCP::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/PIA.h bro-2.1-sdmbn/src/PIA.h
--- bro-2.1/src/PIA.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/PIA.h	2014-02-17 17:20:07.000000003 -0600
@@ -5,6 +5,8 @@
 
 #include "Analyzer.h"
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
+#include <boost/serialization/export.hpp>
 
 class RuleEndpointState;
 
@@ -80,10 +82,16 @@
 
 	Buffer pkt_buffer;
 
+    PIA() {}; // Dummy default constructor for serialization
+
 private:
 	Analyzer* as_analyzer;
 	Connection* conn;
 	DataBlock current_packet;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // PIA for UDP.
@@ -113,6 +121,12 @@
 
 	virtual void ActivateAnalyzer(AnalyzerTag::Tag tag, const Rule* rule);
 	virtual void DeactivateAnalyzer(AnalyzerTag::Tag tag);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    PIA_UDP() {}; // Dummy default constructor for serialization
 };
 
 // PIA for TCP.  Accepts both packet and stream input (and reassembles
@@ -169,6 +183,12 @@
 	Buffer stream_buffer;
 
 	bool stream_mode;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    PIA_TCP() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/PktSrc.cc bro-2.1-sdmbn/src/PktSrc.cc
--- bro-2.1/src/PktSrc.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/PktSrc.cc	2014-04-15 13:53:57.000000003 -0500
@@ -10,7 +10,7 @@
 #include "Hash.h"
 #include "Net.h"
 #include "Sessions.h"
-
+#include "SDMBNlocal.h"
 
 // ### This needs auto-confing.
 #ifdef HAVE_PCAP_INT_H
@@ -614,6 +614,7 @@
 	append = arg_append;
 	dumper = 0;
 
+#ifndef WRITEIFACE
 	// We need a pcap_t with a reasonable link-layer type. We try to get it
 	// from the packet sources. If not available, we fall back to Ethernet.
 	// FIXME: Perhaps we should make this configurable?
@@ -631,6 +632,7 @@
 		Error("error for pcap_open_dead");
 		return;
 		}
+#endif
 
 	if ( arg_filename )
 		Open(arg_filename);
@@ -646,13 +648,18 @@
 
 	if ( arg_filename )
 		{
+#ifndef WRITEIFACE
 		if ( dumper && streq(arg_filename, filename) )
+#else
+		if ( live && streq(arg_filename, filename) )
+#endif
 			// Already open.
 			return true;
 
 		safe_strncpy(filename, arg_filename, FNBUF_LEN);
 		}
 
+#ifndef WRITEIFACE
 	if ( dumper )
 		Close();
 
@@ -681,7 +688,6 @@
 			return false;
 			}
 		}
-
 	else
 		{
 		// Old file and we need to append, which, unfortunately,
@@ -695,6 +701,15 @@
 			return false;
 			}
 		}
+#else
+    errbuf[0] = 0;
+    live =  pcap_open_live(filename, 0, 1, 10, errbuf);
+    if ( ! live )
+        {
+        Error(errbuf);
+        return false;
+        }
+#endif
 
 	open_time = network_time;
 	is_error = false;
@@ -703,25 +718,43 @@
 
 bool PktDumper::Close()
 	{
+#ifndef WRITEIFACE
 	if ( dumper )
 		{
 		pcap_dump_close(dumper);
 		dumper = 0;
 		is_error = false;
 		}
+#else
+    if ( live )
+        {
+        pcap_close(live);
+        live = 0;
+        is_error = false;
+        }
+#endif
 
 	return true;
 	}
 
 bool PktDumper::Dump(const struct pcap_pkthdr* hdr, const u_char* pkt)
 	{
+#ifndef WRITEIFACE
 	if ( ! dumper )
+#else
+    if ( ! live )
+#endif
 		return false;
 
 	if ( ! open_time )
 		open_time = network_time;
 
+#ifndef WRITEIFACE
 	pcap_dump((u_char*) dumper, hdr, pkt);
+#else
+	if (pcap_inject(live, pkt, hdr->caplen) < 0)
+        return false;
+#endif
 
 	return true;
 	}
diff -urN bro-2.1/src/PktSrc.h bro-2.1-sdmbn/src/PktSrc.h
--- bro-2.1/src/PktSrc.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/PktSrc.h	2014-04-15 13:53:57.000000003 -0500
@@ -249,7 +249,13 @@
 	bool append;
 	pcap_dumper_t* dumper;
 	pcap_t* pd;
-	double open_time;
+    double open_time;
+
+    // The "live" field is only needed if WRITEIFACE is defined, but 
+    // including the header where it's defined causes compilation errors,
+    // so we just always include the field
+	pcap_t* live;
+
 
 	bool is_error;
 	char errbuf[BRO_PCAP_ERRBUF_SIZE];
diff -urN bro-2.1/src/Reassem.cc bro-2.1-sdmbn/src/Reassem.cc
--- bro-2.1/src/Reassem.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Reassem.cc	2014-02-17 17:20:07.000000003 -0600
@@ -6,6 +6,11 @@
 
 #include "Reassem.h"
 #include "Serializer.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 const bool DEBUG_reassem = false;
 
@@ -41,6 +46,42 @@
 	Reassembler::total_size += pad_size(size) + padded_sizeof(DataBlock);
 	}
 
+BOOST_CLASS_EXPORT_GUID(DataBlock,"DataBlock")
+template<class Archive>
+void DataBlock::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:DataBlock:%d",__FILE__,__LINE__);
+
+        ar & next;
+        ar & prev;
+        ar & seq;
+        ar & upper;
+
+        // Special handling of block
+        int size = upper-seq;
+        if (!Archive::is_loading::value)
+        { 
+            if (size > 0)
+            { ar & boost::serialization::make_binary_object(block, size); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (size > 0)
+            {
+                block = new u_char[size];
+                ar & boost::serialization::make_binary_object(block, size);
+            }
+            else
+            { block = 0; }
+        }
+    }
+template void DataBlock::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void DataBlock::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 unsigned int Reassembler::total_size = 0;
 
 Reassembler::Reassembler(int init_seq, ReassemblerType arg_type)
@@ -310,3 +351,21 @@
 
 	return  true;
 	}
+
+BOOST_CLASS_EXPORT_GUID(Reassembler,"Reassembler")
+template<class Archive>
+void Reassembler::serialize(Archive & ar, const unsigned int version)
+    {
+        //FIXME: Serialize parent BroObj?
+        
+        ar & blocks;
+        ar & last_block;
+        ar & last_reassem_seq;
+        ar & trim_seq;
+    }
+template void Reassembler::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Reassembler::serialize<boost::archive::text_iarchive>(
+boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/Reassem.h bro-2.1-sdmbn/src/Reassem.h
--- bro-2.1/src/Reassem.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Reassem.h	2014-02-17 17:20:07.000000003 -0600
@@ -5,6 +5,7 @@
 
 #include "Obj.h"
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 class DataBlock {
 public:
@@ -19,6 +20,12 @@
 	DataBlock* prev;	// previous block with lower seq #
 	int seq, upper;
 	u_char* block;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    DataBlock() {}; // Dummy default constructor for serialization
 };
 
 
@@ -72,6 +79,11 @@
 	int trim_seq;	// how far we've trimmed
 
 	static unsigned int total_size;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
 };
 
 inline DataBlock::~DataBlock()
diff -urN bro-2.1/src/RuleMatcher.cc bro-2.1-sdmbn/src/RuleMatcher.cc
--- bro-2.1/src/RuleMatcher.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/RuleMatcher.cc	2014-02-17 17:20:07.000000003 -0600
@@ -9,6 +9,9 @@
 #include "Scope.h"
 #include "File.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 // FIXME: Things that are not fully implemented/working yet:
 //
@@ -159,6 +162,28 @@
 		delete matched_text[j];
 	}
 
+BOOST_CLASS_EXPORT_GUID(RuleEndpointState,"RuleEndpointState")
+template<class Archive>
+void RuleEndpointState::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & is_orig;
+        ar & analyzer;
+        ar & opposite;
+        //ar & pia; //FIXME
+        //ar & matchers; //FIXME
+        //ar & hdr_tests; //FIXME
+        //ar & matched_by_patterns; //FIXME
+        //ar & matched_test; //FIXME
+        ar & payload_size;
+        //ar & matched_rules; //FIXME
+    }
+template void RuleEndpointState::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void RuleEndpointState::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 RuleMatcher::RuleMatcher(int arg_RE_level)
 	{
 	root = new RuleHdrTest(RuleHdrTest::NOPROT, 0, 0, RuleHdrTest::EQ,
@@ -1244,3 +1269,17 @@
 	if ( resp_match_state )
 		rule_matcher->ClearEndpointState(resp_match_state);
 	}
+
+BOOST_CLASS_EXPORT_GUID(RuleMatcherState,"RuleMatcherState")
+template<class Archive>
+void RuleMatcherState::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & orig_match_state;
+        ar & resp_match_state;
+    }
+template void RuleMatcherState::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void RuleMatcherState::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/RuleMatcher.h bro-2.1-sdmbn/src/RuleMatcher.h
--- bro-2.1/src/RuleMatcher.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/RuleMatcher.h	2014-02-17 17:20:07.000000003 -0600
@@ -13,6 +13,7 @@
 #include "Rule.h"
 #include "RuleAction.h"
 #include "RuleCondition.h"
+#include <boost/serialization/access.hpp>
 
 //#define MATCHER_PRINT_STATS
 
@@ -182,6 +183,12 @@
 	int payload_size;
 
 	int_list matched_rules;		// Rules for which all conditions have matched
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    RuleEndpointState() {}; // Dummy default constructor for serialization
 };
 
 
@@ -322,6 +329,10 @@
 private:
 	RuleEndpointState* orig_match_state;
 	RuleEndpointState* resp_match_state;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/SDMBNlocal.cc bro-2.1-sdmbn/src/SDMBNlocal.cc
--- bro-2.1/src/SDMBNlocal.cc	1969-12-31 18:00:00.000000000 -0600
+++ bro-2.1-sdmbn/src/SDMBNlocal.cc	2014-02-17 17:20:07.000000003 -0600
@@ -0,0 +1,30 @@
+#include "SDMBNlocal.h"
+
+int sdmbn_can_serialize(AnalyzerTag::Tag check)
+{
+    switch(check)
+    {
+    case AnalyzerTag::PIA_TCP: //1
+    case AnalyzerTag::PIA_UDP: //2
+    case AnalyzerTag::ICMP: //3
+    case AnalyzerTag::TCP: //4
+    case AnalyzerTag::UDP: //5
+    case AnalyzerTag::DNS: //9
+    case AnalyzerTag::FTP: //11
+    case AnalyzerTag::HTTP: //13
+    case AnalyzerTag::SMTP: //27
+    case AnalyzerTag::SSH: //28
+    case AnalyzerTag::SSL: //34
+    case AnalyzerTag::Teredo: //38
+    case AnalyzerTag::File: //39
+    case AnalyzerTag::ConnSize: //44
+    case AnalyzerTag::ContentLine: //46
+    case AnalyzerTag::NVT: //47
+    case AnalyzerTag::Zip: //48
+        return 1;
+        break;
+    default:
+        fprintf(stderr,"UNHANDLED ANALYZER: %d\n", check);
+        return 0;
+    }
+}
diff -urN bro-2.1/src/SDMBNlocal.h bro-2.1-sdmbn/src/SDMBNlocal.h
--- bro-2.1/src/SDMBNlocal.h	1969-12-31 18:00:00.000000000 -0600
+++ bro-2.1-sdmbn/src/SDMBNlocal.h	2014-04-15 13:53:57.000000003 -0500
@@ -0,0 +1,48 @@
+#ifndef _SDMBNLocal_H_
+#define _SDMBNLocal_H_
+
+#include <stdio.h>
+#include "Conn.h"
+#include "AnalyzerTags.h"
+#include <SDMBN.h>
+
+// Enable the define below to output to a device when using the -w option and // a device name (instead of a filename)
+#define WRITEIFACE
+
+///// DEBUGGING MACROS ///////////////////////////////////////////////////////
+//#define SDMBN_SERIALIZE
+
+#define SDMBN_INFO
+//#define SDMBN_ERROR
+
+#ifdef SDMBN_SERIALIZE
+    #define SERIALIZE_PRINT(...) printf(__VA_ARGS__); printf("\n");
+#else
+    #define SERIALIZE_PRINT(...)
+#endif
+
+#ifdef SDMBN_INFO
+    #define INFO_PRINT(...) printf(__VA_ARGS__); printf("\n");
+    #ifndef SDMBN_ERROR
+        #define SDMBN_ERROR
+    #endif
+#else
+    #define INFO_PRINT(...)
+#endif
+
+#ifdef SDMBN_ERROR
+    #define ERROR_PRINT(...) printf(__VA_ARGS__); printf("\n");
+#else
+    #define ERROR_PRINT(...)
+#endif
+
+///// TYPEDEFS ///////////////////////////////////////////////////////////////
+int sdmbn_can_serialize(AnalyzerTag::Tag check);
+
+///// FUNCTION PROTOTYPES ////////////////////////////////////////////////////
+int local_get_perflow(PerflowKey *key, int id, int raiseEvents, SDMBNExt *unused);
+int local_put_perflow(int hashkey, PerflowKey *key, char *state);
+int local_get_shared(int id);
+int local_put_shared(int hashkey, char *state);
+
+#endif
diff -urN bro-2.1/src/Sessions.cc bro-2.1-sdmbn/src/Sessions.cc
--- bro-2.1/src/Sessions.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Sessions.cc	2014-05-26 20:58:50.000000003 -0500
@@ -32,6 +32,12 @@
 #include "PacketSort.h"
 #include "TunnelEncapsulation.h"
 
+extern "C" {
+#include <SDMBN.h>
+}
+#include "SDMBNlocal.h"
+#include <sys/time.h>
+
 // These represent NetBIOS services on ephemeral ports.  They're numbered
 // so that we can use a single int to hold either an actual TCP/UDP server
 // port or one of these.
@@ -164,8 +170,8 @@
 	}
 
 void NetSessions::DispatchPacket(double t, const struct pcap_pkthdr* hdr,
-			const u_char* pkt, int hdr_size,
-			PktSrc* src_ps, PacketSortElement* pkt_elem)
+    const u_char* pkt, int hdr_size,
+    PktSrc* src_ps, PacketSortElement* pkt_elem)
 	{
 	const struct ip* ip_hdr = 0;
 	const u_char* ip_data = 0;
@@ -264,7 +270,31 @@
 		}
 
 	if ( dump_this_packet && ! record_all_packets )
+#ifndef WRITEIFACE
 		DumpPacket(hdr, pkt);
+#else
+		{
+		// Force packet to be dumped    
+		unsigned char writeablepkt[1514];
+		if (hdr->caplen > 1514)
+			{ 
+			printf("Packet of length %d (%d) is too large\n", hdr->caplen,
+				hdr->len);
+			}
+		else
+			{
+			memcpy(writeablepkt, pkt, hdr->caplen);
+			writeablepkt[6] = 0xAA;
+			writeablepkt[7] = 0xBB;
+			writeablepkt[8] = 0xCC;
+			writeablepkt[9] = 0xDD;
+			writeablepkt[10] = 0xEE;
+			writeablepkt[11] = 0xFF;
+
+			DumpPacket(hdr, writeablepkt);
+			}
+		}
+#endif
 	}
 
 void NetSessions::NextPacketSecondary(double /* t */, const struct pcap_pkthdr* hdr,
@@ -367,10 +397,18 @@
 	return 1;
 	}
 
+// added to count the packets that were received at the src NF after the
+// move
+int drop_counter = 0;
+
+
 void NetSessions::DoNextPacket(double t, const struct pcap_pkthdr* hdr,
 				const IP_Hdr* ip_hdr, const u_char* const pkt,
 				int hdr_size, const EncapsulationStack* encapsulation)
 	{
+	struct timeval recv_time;
+	gettimeofday(&recv_time,NULL);
+
 	uint32 caplen = hdr->caplen - hdr_size;
 	const struct ip* ip4 = ip_hdr->IP4_Hdr();
 
@@ -625,6 +663,15 @@
 		return;
 	}
 
+	char pkttype[10]; 
+	if (80 == ntohs(id.src_port) || 80 == ntohs(id.dst_port))
+	{ sprintf(pkttype, "HTTP"); }
+	else if (443 == ntohs(id.src_port) || 443 == ntohs(id.dst_port))
+	{ sprintf(pkttype, "TLS"); }
+	else
+	{ sprintf(pkttype, "UNKNOWN"); }
+	sdmbn_notify_packet_received(pkttype, &recv_time);
+
 	HashKey* h = BuildConnIDHashKey(id);
 	if ( ! h )
 		reporter->InternalError("hash computation failed");
@@ -636,13 +683,27 @@
 	conn = (Connection*) d->Lookup(h);
 	if ( ! conn )
 		{
+		printf("[SIGDEBUG] Creating a new connection\n");
+		sdmbn_notify_flow_created();
 		conn = NewConn(h, t, &id, data, proto, ip_hdr->FlowLabel(), encapsulation);
 		if ( conn )
+			{
+			conn->initLock();
 			d->Insert(h, conn);
+			}
 		}
 	else
 		{
 		// We already know that connection.
+		if(conn->HasMoved()) {
+			printf("[SIGDEBUG] The state of connection has moved\n");
+			drop_counter++;
+			printf("[SIGMOVE] Drop counter = %d\n", drop_counter);
+			}
+		else {
+			printf("[SIGDEBUG] The state is not moved\n"); 
+			}
+
 		int consistent = CheckConnectionTag(conn);
 		if ( consistent < 0 )
 			{
@@ -657,6 +718,7 @@
 				conn->Event(connection_reused, 0);
 
 			Remove(conn);
+			printf("[SIGDEBUG] Removing and creating a new connection in the consistency check clause\n");
 			conn = NewConn(h, t, &id, data, proto, ip_hdr->FlowLabel(), encapsulation);
 			if ( conn )
 				d->Insert(h, conn);
@@ -681,6 +743,21 @@
 	int is_orig = (id.src_addr == conn->OrigAddr()) &&
 			(id.src_port == conn->OrigPort());
 
+	pthread_mutex_lock(&conn->lock);
+
+	// If marked as MOVED - raise an event
+	if (conn->HasMoved())
+		{
+		/* NO REDIRECT EVENTS
+		sdmbn_raise_reprocess(conn->getGetOpId(), conn->Key()->Hash(), 
+				(struct pcap_pkthdr *)hdr, (u_char *)pkt);
+				*/
+		/* return to stop further processing, in case of reprocess we will
+		* not return */
+		pthread_mutex_unlock(&conn->lock);
+		return;
+		}
+
 	conn->CheckFlowLabel(is_orig, ip_hdr->FlowLabel());
 
 	Val* pkt_hdr_val = 0;
@@ -699,6 +776,8 @@
 				record_packet, record_content,
 			        hdr, pkt, hdr_size);
 
+	pthread_mutex_unlock(&conn->lock);
+
 	if ( f )
 		{
 		// Above we already recorded the fragment in its entirety.
@@ -958,22 +1037,26 @@
 		{
 		c->CancelTimers();
 
-		TCP_Analyzer* ta = (TCP_Analyzer*) c->GetRootAnalyzer();
-		if ( ta && c->ConnTransport() == TRANSPORT_TCP )
+		if (!c->HasMoved())
 			{
-			assert(ta->GetTag() == AnalyzerTag::TCP);
-			TCP_Endpoint* to = ta->Orig();
-			TCP_Endpoint* tr = ta->Resp();
+			TCP_Analyzer* ta = (TCP_Analyzer*) c->GetRootAnalyzer();
+			if ( ta && c->ConnTransport() == TRANSPORT_TCP )
+				{
+				assert(ta->GetTag() == AnalyzerTag::TCP);
+				TCP_Endpoint* to = ta->Orig();
+				TCP_Endpoint* tr = ta->Resp();
 
-			tcp_stats.StateLeft(to->state, tr->state);
+				tcp_stats.StateLeft(to->state, tr->state);
+				}
 			}
 
 		if ( c->IsPersistent() )
 			persistence_serializer->Unregister(c);
+	
+		if (!c->HasMoved())
+			{ c->Done(); }
 
-		c->Done();
-
-		if ( connection_state_remove )
+		if (!c->HasMoved() && connection_state_remove ) 
 			c->Event(connection_state_remove, 0);
 
 		// Zero out c's copy of the key, so that if c has been Ref()'d
@@ -983,17 +1066,17 @@
 
 		switch ( c->ConnTransport() ) {
 		case TRANSPORT_TCP:
-			if ( ! tcp_conns.RemoveEntry(k) )
+			if ( ! tcp_conns.RemoveEntry(k) && !c->HasMoved() )
 				reporter->InternalError("connection missing");
 			break;
 
 		case TRANSPORT_UDP:
-			if ( ! udp_conns.RemoveEntry(k) )
+			if ( ! udp_conns.RemoveEntry(k) && !c->HasMoved() )
 				reporter->InternalError("connection missing");
 			break;
 
 		case TRANSPORT_ICMP:
-			if ( ! icmp_conns.RemoveEntry(k) )
+			if ( ! icmp_conns.RemoveEntry(k) && !c->HasMoved() )
 				reporter->InternalError("connection missing");
 			break;
 
@@ -1001,7 +1084,7 @@
 			reporter->InternalError("unknown transport when removing connection");
 			break;
 		}
-
+		sdmbn_notify_flow_destroyed();
 		Unref(c);
 		delete k;
 		}
diff -urN bro-2.1/src/Sessions.h bro-2.1-sdmbn/src/Sessions.h
--- bro-2.1/src/Sessions.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Sessions.h	2014-02-17 17:20:07.000000003 -0600
@@ -185,6 +185,10 @@
 	unsigned int MemoryAllocation();
 	TCPStateStats tcp_stats;	// keeps statistics on TCP states
 
+	PDict(Connection) tcp_conns;
+	PDict(Connection) udp_conns;
+	PDict(Connection) icmp_conns;
+
 protected:
 	friend class RemoteSerializer;
 	friend class ConnCompressor;
@@ -245,9 +249,6 @@
 			      const EncapsulationStack* encap);
 
 	CompositeHash* ch;
-	PDict(Connection) tcp_conns;
-	PDict(Connection) udp_conns;
-	PDict(Connection) icmp_conns;
 	PDict(FragReassembler) fragments;
 
 	typedef pair<IPAddr, IPAddr> IPPair;
diff -urN bro-2.1/src/SMTP.cc bro-2.1-sdmbn/src/SMTP.cc
--- bro-2.1/src/SMTP.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/SMTP.cc	2014-02-17 17:20:07.000000003 -0600
@@ -9,6 +9,10 @@
 #include "Event.h"
 #include "ContentLine.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/list.hpp>
 
 #undef SMTP_CMD_DEF
 #define SMTP_CMD_DEF(cmd)	#cmd,
@@ -882,3 +886,31 @@
 		mail = 0;
 		}
 	}
+
+BOOST_CLASS_EXPORT_GUID(SMTP_Analyzer,"SMTP_Analyzer")
+template<class Archive>
+void SMTP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & orig_is_sender;
+        ar & expect_sender;
+        ar & expect_recver;
+        ar & state;
+        ar & last_replied_cmd;
+        ar & first_cmd;
+        ar & pending_reply;
+        ar & pipelining;
+        ar & pending_cmd_q;
+        ar & skip_data;
+        ar & orig_record_contents;
+        ar & line_after_gap;
+        ar & mail;
+    }
+template void SMTP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SMTP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/SMTP.h bro-2.1-sdmbn/src/SMTP.h
--- bro-2.1/src/SMTP.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/SMTP.h	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,7 @@
 
 #include "TCP.h"
 #include "MIME.h"
+#include <boost/serialization/access.hpp>
 
 
 #undef SMTP_CMD_DEF
@@ -94,6 +95,12 @@
 					// after a gap
 
 	MIME_Mail* mail;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    SMTP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/SSH.cc bro-2.1-sdmbn/src/SSH.cc
--- bro-2.1/src/SSH.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/SSH.cc	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,9 @@
 #include "SSH.h"
 #include "Event.h"
 #include "ContentLine.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 SSH_Analyzer::SSH_Analyzer(Connection* c)
 : TCP_ApplicationAnalyzer(AnalyzerTag::SSH, c)
@@ -99,3 +102,20 @@
 
 	ConnectionEvent(event, vl);
 	}
+
+BOOST_CLASS_EXPORT_GUID(SSH_Analyzer,"SSH_Analyzer")
+template<class Archive>
+void SSH_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & orig;
+        ar & resp;
+    }
+template void SSH_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SSH_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/SSH.h bro-2.1-sdmbn/src/SSH.h
--- bro-2.1/src/SSH.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/SSH.h	2014-02-17 17:20:07.000000003 -0600
@@ -5,6 +5,7 @@
 
 #include "TCP.h"
 #include "ContentLine.h"
+#include <boost/serialization/access.hpp>
 
 class SSH_Analyzer : public TCP_ApplicationAnalyzer {
 public:
@@ -21,6 +22,12 @@
 private:
 	ContentLine_Analyzer* orig;
 	ContentLine_Analyzer* resp;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    SSH_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/SSL.cc bro-2.1-sdmbn/src/SSL.cc
--- bro-2.1/src/SSL.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/SSL.cc	2014-02-17 17:20:07.000000003 -0600
@@ -2,6 +2,9 @@
 #include "TCP_Reassembler.h"
 #include "Reporter.h"
 #include "util.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 SSL_Analyzer::SSL_Analyzer(Connection* c)
 : TCP_ApplicationAnalyzer(AnalyzerTag::SSL, c)
@@ -58,3 +61,20 @@
 	had_gap = true;
 	interp->NewGap(orig, len);
 	}
+
+BOOST_CLASS_EXPORT_GUID(SSL_Analyzer,"SSL_Analyzer")
+template<class Archive>
+void SSL_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+        //ar & interp; //FIXME
+        if (Archive::is_loading::value) { interp = new binpac::SSL::SSL_Conn(this); } //TMPHACK
+        ar & had_gap;
+    }
+template void SSL_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SSL_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/SSL.h bro-2.1-sdmbn/src/SSL.h
--- bro-2.1/src/SSL.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/SSL.h	2014-02-17 17:20:07.000000003 -0600
@@ -3,6 +3,7 @@
 
 #include "TCP.h"
 #include "ssl_pac.h"
+#include <boost/serialization/access.hpp>
 
 class SSL_Analyzer : public TCP_ApplicationAnalyzer {
 public:
@@ -31,6 +32,11 @@
 	binpac::SSL::SSL_Conn* interp;
 	bool had_gap;
 
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    SSL_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/TCP.cc bro-2.1-sdmbn/src/TCP.cc
--- bro-2.1/src/TCP.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/TCP.cc	2014-02-17 17:20:07.000000003 -0600
@@ -9,6 +9,11 @@
 #include "TCP_Reassembler.h"
 #include "OSFinger.h"
 #include "Event.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/list.hpp>
+#include "SDMBNlocal.h"
 
 namespace { // local namespace
 	const bool DEBUG_tcp_data_sent = false;
@@ -1833,6 +1838,64 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(TCP_Analyzer,"TCP_Analyzer")
+template<class Archive>
+void TCP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TCP_Analyzer:%d",__FILE__,__LINE__);
+
+        // Serialize TransportLayerAnalyzer
+        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this);
+
+        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
+        ar & orig;
+        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
+        ar & resp;
+
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            for (std::list<Analyzer*>::iterator it = packet_children.begin();
+                    it != packet_children.end(); it++)
+            { assert(sdmbn_can_serialize((*it)->GetTag())); }
+        }
+        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
+        ar & packet_children;
+        
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (first_packet_seen << 0); // 2 bits
+            bitfields |= (reassembling << 2);
+            bitfields |= (is_partial << 3);
+            bitfields |= (is_active << 4);
+            bitfields |= (finished << 5);
+            bitfields |= (close_deferred << 6);
+            bitfields |= (deferred_gen_event << 7);
+            bitfields |= (seen_first_ACK << 8);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            first_packet_seen = (bitfields >> 0) & 0x3; // 2 bits
+            reassembling = (bitfields >> 2) & 0x1;
+            is_partial = (bitfields >> 3) & 0x1;
+            is_active = (bitfields >> 4) & 0x1;
+            finished = (bitfields >> 5) & 0x1;
+            close_deferred = (bitfields >> 6) & 0x1;
+            deferred_gen_event = (bitfields >> 7) & 0x1;
+            seen_first_ACK = (bitfields >> 8) & 0x1;
+        }
+        SERIALIZE_PRINT("\t\tTCP_Analyzer:Done");
+    }
+template void TCP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TCP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
+
 void TCP_ApplicationAnalyzer::Init()
 	{
 	Analyzer::Init();
@@ -1918,6 +1981,41 @@
 		static_cast<TCP_SupportAnalyzer*>(sa)->PacketWithRST();
 	}
 
+BOOST_CLASS_EXPORT_GUID(TCP_ApplicationAnalyzer,"TCP_ApplicationAnalyzer")
+template<class Archive>
+void TCP_ApplicationAnalyzer::serialize(Archive & ar, 
+        const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TCP_ApplicationAnalyzer:%d",__FILE__,__LINE__);
+
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>( *this );
+        
+        SERIALIZE_PRINT("\t\tTCP_ApplicationAnalyzer:%d",__LINE__);
+        ar & tcp; 
+        SERIALIZE_PRINT("\t\tTCP_ApplicationAnalyzer:Done");
+    }
+template void TCP_ApplicationAnalyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TCP_ApplicationAnalyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
+
+BOOST_CLASS_EXPORT_GUID(TCP_SupportAnalyzer,"TCP_SupportAnalyzer")
+template<class Archive>
+void TCP_SupportAnalyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize SupportAnalyzer
+        ar & boost::serialization::base_object<SupportAnalyzer>(*this);
+    }
+template void TCP_SupportAnalyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TCP_SupportAnalyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 TCPStats_Endpoint::TCPStats_Endpoint(TCP_Endpoint* e)
 	{
 	endp = e;
@@ -2049,6 +2147,28 @@
 	return stats;
 	}
 
+BOOST_CLASS_EXPORT_GUID(TCPStats_Endpoint,"TCPStats_Endpoint")
+template<class Archive>
+void TCPStats_Endpoint::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & endp;
+        ar & num_pkts;
+        ar & num_rxmit;
+        ar & num_rxmit_bytes;
+        ar & num_in_order;
+        ar & num_OO;
+        ar & num_repl;
+        ar & max_top_seq;
+        ar & last_id;
+        ar & endian_type;
+    }
+template void TCPStats_Endpoint::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TCPStats_Endpoint::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
+
 TCPStats_Analyzer::TCPStats_Analyzer(Connection* c)
 : TCP_ApplicationAnalyzer(AnalyzerTag::TCPStats, c)
 	{
@@ -2088,3 +2208,20 @@
 	else
 		resp_stats->DataSent(network_time, seq, len, caplen, data, ip, 0);
 	}
+
+BOOST_CLASS_EXPORT_GUID(TCPStats_Analyzer,"TCPStats_Analyzer")
+template<class Archive>
+void TCPStats_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & orig_stats;
+        ar & resp_stats;
+    }
+template void TCPStats_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TCPStats_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
diff -urN bro-2.1/src/TCP_Endpoint.cc bro-2.1-sdmbn/src/TCP_Endpoint.cc
--- bro-2.1/src/TCP_Endpoint.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/TCP_Endpoint.cc	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,10 @@
 #include "Event.h"
 #include "File.h"
 #include "Val.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 TCP_Endpoint::TCP_Endpoint(TCP_Analyzer* arg_analyzer, int arg_is_orig)
 	{
@@ -21,11 +25,13 @@
 	window_scale = 0;
 	window_seq = window_ack_seq = 0;
 	contents_start_seq = 0;
+    FIN_seq = 0;
 	SYN_cnt = FIN_cnt = RST_cnt = 0;
 	did_close = 0;
 	contents_file = 0;
 	tcp_analyzer = arg_analyzer;
 	is_orig = arg_is_orig;
+    hist_last_SYN = hist_last_FIN = hist_last_RST = 0;
 
 	src_addr = is_orig ? tcp_analyzer->Conn()->RespAddr() :
 				tcp_analyzer->Conn()->OrigAddr();
@@ -245,3 +251,47 @@
 	tcp_analyzer->Conn()->AddHistory(code);
 	}
 
+BOOST_CLASS_EXPORT_GUID(TCP_Endpoint,"TCP_Endpoint")
+template<class Archive>
+void TCP_Endpoint::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TCP_Endpoint:%d",__FILE__,__LINE__);
+
+        ar & state;
+        ar & prev_state;
+        ar & peer;
+        ar & contents_processor;
+        ar & tcp_analyzer;
+        ar & contents_file;
+        ar & checksum_base;
+        ar & start_time;
+        ar & last_time;
+        ar & src_addr;
+        ar & dst_addr;
+        ar & window;
+        ar & window_scale;
+        ar & window_ack_seq;
+        ar & window_seq;
+        ar & contents_start_seq;
+        ar & FIN_seq;
+        ar & SYN_cnt;
+        ar & FIN_cnt;
+        ar & RST_cnt;
+        ar & did_close;
+        ar & is_orig;
+        ar & hist_last_SYN;
+        ar & hist_last_FIN;
+        ar & hist_last_RST;
+        ar & start_seq;
+        ar & last_seq;
+        ar & ack_seq;
+        ar & last_seq_high;
+        ar & ack_seq_high;
+        SERIALIZE_PRINT("\t\tTCP_Endpoint:Done");
+    }   
+template void TCP_Endpoint::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TCP_Endpoint::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/TCP_Endpoint.h bro-2.1-sdmbn/src/TCP_Endpoint.h
--- bro-2.1/src/TCP_Endpoint.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/TCP_Endpoint.h	2014-02-17 17:20:07.000000003 -0600
@@ -4,6 +4,7 @@
 #define tcpendpoint_h
 
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 typedef enum {
 	TCP_ENDPOINT_INACTIVE,	// no SYN (or other packets) seen for this side
@@ -150,6 +151,12 @@
 protected:
 	uint32 start_seq, last_seq, ack_seq;	// in host order
 	uint32 last_seq_high, ack_seq_high;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    TCP_Endpoint() {}; // Dummy default constructor for serialization
 };
 
 #define ENDIAN_UNKNOWN 0
diff -urN bro-2.1/src/TCP.h bro-2.1-sdmbn/src/TCP.h
--- bro-2.1/src/TCP.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/TCP.h	2014-02-17 17:20:07.000000003 -0600
@@ -7,6 +7,7 @@
 #include "TCP.h"
 #include "PacketDumper.h"
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 // We define two classes here:
 // - TCP_Analyzer is the analyzer for the TCP protocol itself.
@@ -256,6 +257,12 @@
 
 	// Whether we have seen the first ACK from the originator.
 	unsigned int seen_first_ACK: 1;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TCP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 class TCP_ApplicationAnalyzer : public Analyzer {
@@ -312,6 +319,10 @@
 
 private:
 	TCP_Analyzer* tcp;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TCP_SupportAnalyzer : public SupportAnalyzer {
@@ -328,6 +339,12 @@
 	virtual void ConnectionFinished(int half_finished)	{ }
 	virtual void ConnectionReset()	{ }
 	virtual void PacketWithRST()	{ }
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TCP_SupportAnalyzer() {}; // Dummy default constructor for serialization
 };
 
 
@@ -351,6 +368,12 @@
 	int max_top_seq;
 	int last_id;
 	int endian_type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TCPStats_Endpoint() {}; // Dummy default constructor for serialization
 };
 
 class TCPStats_Analyzer : public TCP_ApplicationAnalyzer {
@@ -372,6 +395,12 @@
 
 	TCPStats_Endpoint* orig_stats;
 	TCPStats_Endpoint* resp_stats;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    TCPStats_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/TCP_Reassembler.cc bro-2.1-sdmbn/src/TCP_Reassembler.cc
--- bro-2.1/src/TCP_Reassembler.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/TCP_Reassembler.cc	2014-02-17 17:20:07.000000003 -0600
@@ -4,6 +4,10 @@
 #include "TCP_Reassembler.h"
 #include "TCP.h"
 #include "TCP_Endpoint.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 // Only needed for gap_report events.
 #include "Event.h"
@@ -665,3 +669,65 @@
 
 	return 0;
 	}
+
+BOOST_CLASS_EXPORT_GUID(TCP_Reassembler,"TCP_Reassembler")
+template<class Archive>
+void TCP_Reassembler::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TCP_Reassembler:%d",__FILE__,__LINE__);
+
+        // Serialize Reassembler
+        ar & boost::serialization::base_object<Reassembler>(*this);
+
+        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
+        ar & endp;
+
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (deliver_tcp_contents << 0);
+            bitfields |= (had_gap << 1);
+            bitfields |= (did_EOF << 2);
+            bitfields |= (skip_deliveries << 3);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            deliver_tcp_contents = (bitfields >> 0) & 0x1;
+            had_gap = (bitfields >> 1) & 0x1;
+            did_EOF = (bitfields >> 2) & 0x1;
+            skip_deliveries = (bitfields >> 3) & 0x1;
+        }
+     
+#ifdef ENABLE_SEQ_TO_SKIP
+	    ar & seq_to_skip;
+#endif
+        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
+        ar & in_delivery;
+        //ar & record_contents_file; //FIXME
+        if (Archive::is_loading::value) { record_contents_file = NULL; } //TMPHACK
+        
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            if (dst_analyzer != NULL)
+            { assert(sdmbn_can_serialize(dst_analyzer->GetTag())); }
+
+            if (tcp_analyzer != NULL)
+            { assert(sdmbn_can_serialize(tcp_analyzer->GetTag())); }
+        }
+        ar & dst_analyzer;
+        ar & tcp_analyzer;
+
+        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
+        ar & type;
+        ar & is_orig;
+        SERIALIZE_PRINT("\t\tTCP_Reassembler:Done");
+    }
+template void TCP_Reassembler::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TCP_Reassembler::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/TCP_Reassembler.h bro-2.1-sdmbn/src/TCP_Reassembler.h
--- bro-2.1/src/TCP_Reassembler.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/TCP_Reassembler.h	2014-02-17 17:20:07.000000003 -0600
@@ -3,6 +3,7 @@
 
 #include "Reassem.h"
 #include "TCP_Endpoint.h"
+#include <boost/serialization/access.hpp>
 
 // The skip_to_seq feature does not work correctly with connections >2GB due
 // to use of 32 bit signed ints (see comments in TCP_Reassembler.cc) Since
@@ -130,6 +131,10 @@
 
 	Type type;
 	bool is_orig;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/Teredo.cc bro-2.1-sdmbn/src/Teredo.cc
--- bro-2.1/src/Teredo.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Teredo.cc	2014-02-17 17:20:07.000000003 -0600
@@ -2,6 +2,9 @@
 #include "Teredo.h"
 #include "IP.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 void Teredo_Analyzer::Done()
 	{
@@ -9,6 +12,20 @@
 	Event(udp_session_done);
 	}
 
+BOOST_CLASS_EXPORT_GUID(Teredo_Analyzer,"Teredo_Analyzer")
+template<class Archive>
+void Teredo_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize Analyzer 
+        ar & boost::serialization::base_object<Analyzer>(*this);
+    }
+template void Teredo_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Teredo_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 bool TeredoEncapsulation::DoParse(const u_char* data, int& len,
                                   bool found_origin, bool found_auth)
 	{
diff -urN bro-2.1/src/Teredo.h bro-2.1-sdmbn/src/Teredo.h
--- bro-2.1/src/Teredo.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Teredo.h	2014-02-17 17:20:07.000000003 -0600
@@ -3,6 +3,7 @@
 
 #include "Analyzer.h"
 #include "NetVar.h"
+#include <boost/serialization/access.hpp>
 
 class Teredo_Analyzer : public Analyzer {
 public:
@@ -38,6 +39,12 @@
 protected:
 	friend class AnalyzerTimer;
 	void ExpireTimer(double t);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    Teredo_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 class TeredoEncapsulation {
diff -urN bro-2.1/src/Timer.cc bro-2.1-sdmbn/src/Timer.cc
--- bro-2.1/src/Timer.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Timer.cc	2014-02-17 17:20:07.000000003 -0600
@@ -6,6 +6,10 @@
 #include "Timer.h"
 #include "Desc.h"
 #include "Serializer.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 // Names of timers in same order than in TimerType.
 const char* TimerNames[] = {
@@ -86,6 +90,33 @@
 	return UNSERIALIZE(&time);
 	}
 
+BOOST_CLASS_EXPORT_GUID(Timer,"Timer")
+template<class Archive>
+void Timer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Timer:%d",__FILE__,__LINE__);
+        // Serialize PQ_Element
+//        ar & boost::serialization::base_object<PQ_Element>(*this);
+
+        // Special handling of bit field
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (type << 0);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            type = (bitfields >> 0) & 0xFF;
+        } 
+    }
+template void Timer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Timer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 unsigned int TimerMgr::current_timers[NUM_TIMER_TYPES];
 
 TimerMgr::~TimerMgr()
@@ -106,6 +137,24 @@
 	return DoAdvance(t, max_expire);
 	}
 
+BOOST_CLASS_EXPORT_GUID(TimerMgr,"TimerMgr")
+template<class Archive>
+void TimerMgr::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TimerMgr:%d",__FILE__,__LINE__);
+
+        ar & t;
+        ar & last_timestamp;
+        ar & last_advance;
+        ar & tag;
+        ar & num_expired;
+    }
+template void TimerMgr::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TimerMgr::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 PQ_TimerMgr::PQ_TimerMgr(const Tag& tag) : TimerMgr(tag)
 	{
@@ -178,6 +227,24 @@
 	delete timer;
 	}
 
+BOOST_CLASS_EXPORT_GUID(PQ_TimerMgr,"PQ_TimerMgr")
+template<class Archive>
+void PQ_TimerMgr::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PQ_TimerMgr:%d",__FILE__,__LINE__);
+        // Serialize TimerMgr
+        ar & boost::serialization::base_object<TimerMgr>(*this);
+
+        //ar & q; //FIXME
+        if (Archive::is_loading::value) { q = NULL; } //TMPHACK
+    }
+template void PQ_TimerMgr::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PQ_TimerMgr::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 CQ_TimerMgr::CQ_TimerMgr(const Tag& tag) : TimerMgr(tag)
 	{
 	cq = cq_init(60.0, 1.0);
@@ -260,3 +327,21 @@
 		delete timer;
 		}
 	}
+
+BOOST_CLASS_EXPORT_GUID(CQ_TimerMgr,"CQ_TimerMgr")
+template<class Archive>
+void CQ_TimerMgr::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:CQ_TimerMgr:%d",__FILE__,__LINE__);
+        // Serialize TimerMgr
+        ar & boost::serialization::base_object<TimerMgr>(*this);
+
+        //ar & cq; //FIXME
+        if (Archive::is_loading::value) { cq = NULL; } //TMPHACK
+    }
+template void CQ_TimerMgr::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void CQ_TimerMgr::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/Timer.h bro-2.1-sdmbn/src/Timer.h
--- bro-2.1/src/Timer.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Timer.h	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,7 @@
 #include <string>
 #include "SerialObj.h"
 #include "PriorityQueue.h"
+#include <boost/serialization/access.hpp>
 
 extern "C" {
 #include "cq.h"
@@ -75,6 +76,10 @@
 	DECLARE_ABSTRACT_SERIAL(Timer);
 
 	unsigned int type:8;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TimerMgr {
@@ -135,6 +140,12 @@
 	int num_expired;
 
 	static unsigned int current_timers[NUM_TIMER_TYPES];
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    TimerMgr() {}; // Dummy default constructor for serialization
 };
 
 class PQ_TimerMgr : public TimerMgr {
@@ -157,6 +168,12 @@
 	Timer* Top()			{ return (Timer*) q->Top(); }
 
 	PriorityQueue* q;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    PQ_TimerMgr() {}; // Dummy default constructor for serialization
 };
 
 class CQ_TimerMgr : public TimerMgr {
@@ -176,6 +193,12 @@
 	void Remove(Timer* timer);
 
 	struct cq_handle *cq;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    CQ_TimerMgr() {}; // Dummy default constructor for serialization
 };
 
 extern TimerMgr* timer_mgr;
diff -urN bro-2.1/src/TunnelEncapsulation.cc bro-2.1-sdmbn/src/TunnelEncapsulation.cc
--- bro-2.1/src/TunnelEncapsulation.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/TunnelEncapsulation.cc	2014-02-17 17:20:07.000000003 -0600
@@ -3,6 +3,10 @@
 #include "TunnelEncapsulation.h"
 #include "util.h"
 #include "Conn.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/vector.hpp>
 
 EncapsulatingConn::EncapsulatingConn(Connection* c, BifEnum::Tunnel::Type t)
 		: src_addr(c->OrigAddr()), dst_addr(c->RespAddr()),
@@ -34,6 +38,25 @@
 	return rv;
 	}
 
+BOOST_CLASS_EXPORT_GUID(EncapsulatingConn,"EncapsulatingConn")
+template<class Archive>
+void EncapsulatingConn::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & src_addr;
+        ar & dst_addr;
+        ar & src_port;
+        ar & dst_port;
+        ar & proto;
+        ar & type;
+        ar & uid;
+    }
+template void EncapsulatingConn::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void EncapsulatingConn::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 bool operator==(const EncapsulationStack& e1, const EncapsulationStack& e2)
 	{
 	if ( ! e1.conns )
@@ -53,3 +76,17 @@
 
 	return true;
 	}
+
+BOOST_CLASS_EXPORT_GUID(EncapsulationStack,"EncapsulationStack")
+template<class Archive>
+void EncapsulationStack::serialize(Archive & ar, const unsigned int version)
+    {
+        printf("%s:EncapsulationStack:%d\n",__FILE__,__LINE__);
+//        ar & conns; //REINCLUDE
+    }
+template void EncapsulationStack::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void EncapsulationStack::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/TunnelEncapsulation.h bro-2.1-sdmbn/src/TunnelEncapsulation.h
--- bro-2.1/src/TunnelEncapsulation.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/TunnelEncapsulation.h	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,8 @@
 #include "IPAddr.h"
 #include "Val.h"
 #include <vector>
+#include <boost/serialization/access.hpp>
+#include <boost/serialization/vector.hpp>
 
 class Connection;
 
@@ -109,6 +111,10 @@
 	TransportProto proto;
 	BifEnum::Tunnel::Type type;
 	uint64 uid;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 /**
@@ -203,6 +209,10 @@
 
 protected:
 	vector<EncapsulatingConn>* conns;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff -urN bro-2.1/src/Type.cc bro-2.1-sdmbn/src/Type.cc
--- bro-2.1/src/Type.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Type.cc	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,12 @@
 #include "Scope.h"
 #include "Serializer.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include <boost/serialization/list.hpp>
+#include "SDMBNlocal.h"
 
 #include <string>
 #include <list>
@@ -290,6 +296,59 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(BroType,"BroType")
+template<class Archive>
+void BroType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BroType:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        SERIALIZE_PRINT("\t\tBroType:%d",__LINE__);
+        ar & tag;
+        ar & internal_tag;
+        ar & is_network_order;
+        ar & base_type;
+
+        // Special handling of type_id 
+        SERIALIZE_PRINT("\t\tBroType:%d",__LINE__);
+        int type_id_len;
+        if (!Archive::is_loading::value)
+        {   
+            if (NULL == type_id)
+            { type_id_len = 0; }
+            else
+            { type_id_len = strlen(type_id)+1; } 
+        }
+        ar & type_id_len;
+        if (!Archive::is_loading::value)
+        { 
+            if (type_id_len > 0)
+            {
+                ar & boost::serialization::make_binary_object((void *)type_id, 
+                        type_id_len); 
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (type_id_len > 0)
+            {
+                type_id = new char[type_id_len];
+                ar & boost::serialization::make_binary_object(
+                        const_cast<char* &>(type_id), type_id_len);
+            }
+            else
+            { type_id = NULL; }
+        }
+        SERIALIZE_PRINT("\t\tBroType:Done");
+    }
+template void BroType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BroType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 TypeList::~TypeList()
 	{
 	loop_over_list(types, i)
@@ -393,6 +452,24 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(TypeList,"TypeList")
+template<class Archive>
+void TypeList::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TypeList:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & pure_type;
+        ar & types;
+    }
+template void TypeList::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TypeList::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 IndexType::~IndexType()
 	{
 	Unref(indices);
@@ -513,6 +590,24 @@
 	return indices != 0;
 	}
 
+BOOST_CLASS_EXPORT_GUID(IndexType,"IndexType")
+template<class Archive>
+void IndexType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:IndexType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & indices;
+        ar & yield_type;
+    }
+template void IndexType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void IndexType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 TableType::TableType(TypeList* ind, BroType* yield)
 : IndexType(TYPE_TABLE, ind, yield)
 	{
@@ -628,6 +723,21 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(TableType,"TableType")
+template<class Archive>
+void TableType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TableType:%d",__FILE__,__LINE__);
+        // Serialize IndexType
+        ar & boost::serialization::base_object<IndexType>(*this);
+    }
+template void TableType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TableType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 SetType::~SetType()
 	{
 	Unref(elements);
@@ -651,6 +761,24 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(SetType,"SetType")
+template<class Archive>
+void SetType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:SetType:%d",__FILE__,__LINE__);
+        // Serialize TableType
+        ar & boost::serialization::base_object<TableType>(*this);
+
+        //ar & elements; //FIXME
+        if (Archive::is_loading::value) { elements = NULL; } //TMPHACK
+    }
+template void SetType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SetType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 FuncType::FuncType(RecordType* arg_args, BroType* arg_yield, int arg_is_event)
 : BroType(TYPE_FUNC)
 	{
@@ -777,6 +905,42 @@
 	return UNSERIALIZE(&is_event);
 	}
 
+BOOST_CLASS_EXPORT_GUID(FuncType,"FuncType")
+template<class Archive>
+void FuncType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:FuncType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & args;
+        ar & arg_types;
+        ar & yield;
+        ar & is_event;
+        ar & return_value;
+    }
+template void FuncType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void FuncType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
+BOOST_CLASS_EXPORT_GUID(TypeType,"TypeType")
+template<class Archive>
+void TypeType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TypeType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+    }
+template void TypeType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TypeType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 TypeDecl::TypeDecl(BroType* t, const char* i, attr_list* arg_attrs, bool in_record)
 	{
 	type = t;
@@ -841,6 +1005,24 @@
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(TypeDecl,"TypeDecl")
+template<class Archive>
+void TypeDecl::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TypeDecl:%d",__FILE__,__LINE__);
+
+        ar & type;
+        ar & attrs;
+        //ar & id; //FIXME
+        if (Archive::is_loading::value) { id = NULL; } //TMPHACK
+    }
+template void TypeDecl::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TypeDecl::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 CommentedTypeDecl::CommentedTypeDecl(BroType* t, const char* i,
 			attr_list* attrs, bool in_record, std::list<std::string>* cmnt_list)
 	: TypeDecl(t, i, attrs, in_record)
@@ -872,6 +1054,23 @@
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(CommentedTypeDecl,"CommentedTypeDecl")
+template<class Archive>
+void CommentedTypeDecl::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:CommentedTypeDecl:%d",__FILE__,__LINE__);
+        // Serialize TypeDecl
+        ar & boost::serialization::base_object<TypeDecl>(*this);
+
+        ar & comments;
+    }
+template void CommentedTypeDecl::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void CommentedTypeDecl::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 RecordType::RecordType(type_decl_list* arg_types) : BroType(TYPE_RECORD)
 	{
 	types = arg_types;
@@ -1128,6 +1327,24 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(RecordType,"RecordType")
+template<class Archive>
+void RecordType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:RecordType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & num_fields;
+        ar & types; 
+    }
+template void RecordType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void RecordType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 SubNetType::SubNetType() : BroType(TYPE_SUBNET)
 	{
 	}
@@ -1154,6 +1371,21 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(SubNetType,"SubNetType")
+template<class Archive>
+void SubNetType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:SubNetType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+    }
+template void SubNetType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SubNetType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 FileType::FileType(BroType* yield_type)
 : BroType(TYPE_FILE)
 	{
@@ -1202,6 +1434,23 @@
 	return yield != 0;
 	}
 
+BOOST_CLASS_EXPORT_GUID(FileType,"FileType")
+template<class Archive>
+void FileType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:FileType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & yield;
+    }
+template void FileType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void FileType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 EnumType::EnumType()
 : BroType(TYPE_ENUM)
 	{
@@ -1418,6 +1667,41 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(EnumType,"EnumType")
+template<class Archive>
+void EnumType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:EnumType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        //ar & names; //FIXME
+        ar & counter;
+    }
+template void EnumType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void EnumType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
+BOOST_CLASS_EXPORT_GUID(CommentedEnumType,"CommentedEnumType")
+template<class Archive>
+void CommentedEnumType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:CommentedEnumType:%d",__FILE__,__LINE__);
+        // Serialize EnumType
+        ar & boost::serialization::base_object<EnumType>(*this);
+
+        //ar & comments; //FIXME
+    }
+template void CommentedEnumType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void CommentedEnumType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 VectorType::VectorType(BroType* element_type)
 : BroType(TYPE_VECTOR)
 	{
@@ -1477,6 +1761,23 @@
 	yield_type->Describe(d);
 	}
 
+BOOST_CLASS_EXPORT_GUID(VectorType,"VectorType")
+template<class Archive>
+void VectorType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:VectorType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & yield_type;
+    }
+template void VectorType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void VectorType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 BroType* base_type(TypeTag tag)
 	{
 	static BroType* base_types[NUM_TYPES];
diff -urN bro-2.1/src/Type.h bro-2.1-sdmbn/src/Type.h
--- bro-2.1/src/Type.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Type.h	2014-02-17 17:20:07.000000003 -0600
@@ -11,6 +11,7 @@
 #include "Attr.h"
 #include "BroList.h"
 #include "Dict.h"
+#include <boost/serialization/access.hpp>
 
 // BRO types.
 
@@ -241,6 +242,10 @@
 	// This type_id field is only used by the documentation framework to
 	// track the names of declared types.
 	const char* type_id;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TypeList : public BroType {
@@ -285,6 +290,10 @@
 
 	BroType* pure_type;
 	type_list types;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class IndexType : public BroType {
@@ -315,6 +324,10 @@
 
 	TypeList* indices;
 	BroType* yield_type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TableType : public IndexType {
@@ -331,6 +344,10 @@
 	TypeList* ExpandRecordIndex(RecordType* rt) const;
 
 	DECLARE_SERIAL(TableType)
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class SetType : public TableType {
@@ -346,6 +363,10 @@
 	ListExpr* elements;
 
 	DECLARE_SERIAL(SetType)
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class FuncType : public BroType {
@@ -382,6 +403,10 @@
 	BroType* yield;
 	int is_event;
 	ID* return_value;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TypeType : public BroType {
@@ -395,6 +420,10 @@
 	TypeType()	{}
 
 	BroType* type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TypeDecl {
@@ -413,6 +442,12 @@
 	BroType* type;
 	Attributes* attrs;
 	const char* id;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TypeDecl() {}; // Dummy default constructor for serialization
 };
 
 class CommentedTypeDecl : public TypeDecl {
@@ -424,6 +459,12 @@
 	void DescribeReST(ODesc* d) const;
 
 	std::list<std::string>* comments;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    CommentedTypeDecl() {}; // Dummy default constructor for serialization
 };
 
 class RecordType : public BroType {
@@ -468,6 +509,10 @@
 
 	int num_fields;
 	type_decl_list* types;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class SubNetType : public BroType {
@@ -476,6 +521,10 @@
 	void Describe(ODesc* d) const;
 protected:
 	DECLARE_SERIAL(SubNetType)
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class FileType : public BroType {
@@ -493,6 +542,10 @@
 	DECLARE_SERIAL(FileType)
 
 	BroType* yield;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class EnumType : public BroType {
@@ -529,6 +582,10 @@
 	// as a flag to prevent mixing of auto-increment and explicit
 	// enumerator specifications.
 	bro_int_t counter;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class CommentedEnumType: public EnumType {
@@ -550,6 +607,10 @@
 	// Comments are only filled when in "documentation mode".
 	typedef std::map< const char*, std::list<std::string>*, ltstr > CommentMap;
 	CommentMap comments;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class VectorType : public BroType {
@@ -572,6 +633,10 @@
 	DECLARE_SERIAL(VectorType)
 
 	BroType* yield_type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // Returns the BRO basic (non-parameterized) type with the given type.
diff -urN bro-2.1/src/UDP.cc bro-2.1-sdmbn/src/UDP.cc
--- bro-2.1/src/UDP.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/UDP.cc	2014-02-17 17:20:07.000000003 -0600
@@ -8,6 +8,10 @@
 #include "NetVar.h"
 #include "UDP.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 UDP_Analyzer::UDP_Analyzer(Connection* conn)
 : TransportLayerAnalyzer(AnalyzerTag::UDP, conn)
@@ -227,3 +231,22 @@
 
 	return sum == 0xffff;
 	}
+
+BOOST_CLASS_EXPORT_GUID(UDP_Analyzer,"UDP_Analyzer")
+template<class Archive>
+void UDP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:UDP_Analyzer:%d",__FILE__,__LINE__);
+
+        // Serialize TransportLayerAnalyzer
+        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this); 
+        ar & request_len;
+        ar & reply_len;
+        SERIALIZE_PRINT("\t\tUDP_Analyzer:Done");
+    }
+template void UDP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void UDP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/UDP.h bro-2.1-sdmbn/src/UDP.h
--- bro-2.1/src/UDP.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/UDP.h	2014-02-17 17:20:07.000000003 -0600
@@ -5,6 +5,7 @@
 
 #include "Analyzer.h"
 #include <netinet/udp.h>
+#include <boost/serialization/access.hpp>
 
 typedef enum {
 	UDP_INACTIVE,	// no packet seen
@@ -45,6 +46,12 @@
 #define HIST_RESP_DATA_PKT 0x2
 #define HIST_ORIG_CORRUPT_PKT 0x4
 #define HIST_RESP_CORRUPT_PKT 0x8
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    UDP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/src/Val.cc bro-2.1-sdmbn/src/Val.cc
--- bro-2.1/src/Val.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Val.cc	2014-02-17 17:20:07.000000003 -0600
@@ -26,10 +26,17 @@
 #include "Conn.h"
 #include "Reporter.h"
 #include "IPAddr.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/list.hpp>
+#include <boost/serialization/vector.hpp>
+#include "SDMBNlocal.h"
 
 Val::Val(Func* f)
 	{
 	val.func_val = f;
+    val_type = BROVALUNION_FUNC;
 	type = f->FType()->Ref();
 	attribs = 0;
 #ifdef DEBUG
@@ -44,6 +51,7 @@
 		string_file_type = new FileType(base_type(TYPE_STRING));
 
 	val.file_val = f;
+    val_type = BROVALUNION_FILE;
 
 	assert(f->FType()->Tag() == TYPE_STRING);
 	type = string_file_type->Ref();
@@ -163,6 +171,7 @@
 					// Different, so let's bind the val
 					// to the local type.
 					v->val.int_val = lv;
+                    v->val_type = BROVALUNION_INT;
 					Unref(rt);
 					v->type = lt;
 					::Ref(lt);
@@ -270,18 +279,21 @@
 			return false;
 
 		val.string_val = new BroString((u_char*) str, len, 1);
+        val_type = BROVALUNION_STRING;
 		delete [] str;
 		return true;
 
 	case TYPE_INTERNAL_ADDR:
 		{
 		val.addr_val = new IPAddr();
+        val_type = BROVALUNION_ADDR;
 		return UNSERIALIZE(val.addr_val);
 		}
 
 	case TYPE_INTERNAL_SUBNET:
 		{
 		val.subnet_val = new IPPrefix();
+        val_type = BROVALUNION_SUBNET;
 		return UNSERIALIZE(val.subnet_val);
 		}
 
@@ -292,11 +304,13 @@
 		if ( type->Tag() == TYPE_FUNC )
 			{
 			val.func_val = Func::Unserialize(info);
+            val_type = BROVALUNION_FUNC;
 			return val.func_val != 0;
 			}
 		else if ( type->Tag() == TYPE_FILE )
 			{
 			val.file_val = BroFile::Unserialize(info);
+            val_type = BROVALUNION_FILE;
 			return val.file_val != 0;
 			}
 		return true;
@@ -532,6 +546,112 @@
 	}
 	}
 
+BOOST_CLASS_EXPORT_GUID(Val,"Val")
+template<class Archive>
+void Val::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Val:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+        
+        ar & val_type;
+
+        // Special handling of value union
+        if (!Archive::is_loading::value)
+        {
+            switch(val_type)
+            {
+            case BROVALUNION_INT:
+                ar & val.int_val;
+                break;
+            case BROVALUNION_UINT:
+                ar & val.uint_val;
+                break;
+            case BROVALUNION_ADDR:
+                ar & val.addr_val;
+                break;
+            case BROVALUNION_SUBNET:
+                ar & val.subnet_val;
+                break;
+            case BROVALUNION_DOUBLE:
+                ar & val.double_val;
+                break;
+            case BROVALUNION_STRING:
+                ar & val.string_val;
+                break;
+            case BROVALUNION_FUNC:
+                break;
+            case BROVALUNION_FILE:
+                ar & val.file_val;
+                break;
+            case BROVALUNION_RE:
+            case BROVALUNION_TABLE:
+            case BROVALUNION_LIST:
+                break;
+            case BROVALUNION_VECTOR:
+                ar & val.vector_val;
+                break;
+            default:
+                SERIALIZE_PRINT("ERROR: Unknown type for Val");
+                break;
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            switch(val_type)
+            {
+            case BROVALUNION_INT:
+                ar & val.int_val;
+                break;
+            case BROVALUNION_UINT:
+                ar & val.uint_val;
+                break;
+            case BROVALUNION_ADDR:
+                ar & val.addr_val;
+                break;
+            case BROVALUNION_SUBNET:
+                ar & val.subnet_val;
+                break;
+            case BROVALUNION_DOUBLE:
+                ar & val.double_val;
+                break;
+            case BROVALUNION_STRING:
+                ar & val.string_val;
+                break;
+            case BROVALUNION_FUNC:
+                val.func_val = NULL; //TMPHACK
+                break;
+            case BROVALUNION_FILE:
+                ar & val.file_val;
+                break;
+            case BROVALUNION_RE:
+                val.re_val = NULL; //TMPHACK
+                break;
+            case BROVALUNION_TABLE:
+                val.table_val = NULL; //TMPHACK
+                break;
+            case BROVALUNION_LIST:
+                val.val_list_val = NULL; //TMPHACK
+                break;
+            case BROVALUNION_VECTOR:
+                ar & val.vector_val;
+                break;
+            default:
+                SERIALIZE_PRINT("ERROR: Unknown type for Val");
+                break;
+            }
+        }
+
+        ar & type; 
+        ar & attribs;
+    }
+template void Val::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Val::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 MutableVal::~MutableVal()
 	{
 	for ( list<ID*>::iterator i = aliases.begin(); i != aliases.end(); ++i )
@@ -709,6 +829,26 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(MutableVal,"MutableVal")
+template<class Archive>
+void MutableVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:MutableVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+
+        ar & id;
+        ar & aliases;
+        ar & props;
+        ar & last_modified;
+    }
+template void MutableVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MutableVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 IntervalVal::IntervalVal(double quantity, double units) :
 	Val(quantity * units, TYPE_INTERVAL)
 	{
@@ -765,6 +905,21 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(IntervalVal,"IntervalVal")
+template<class Archive>
+void IntervalVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:IntervalVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void IntervalVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void IntervalVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 PortVal::PortVal(uint32 p, TransportProto port_type) : Val(TYPE_PORT)
 	{
 	// Note, for ICMP one-way connections:
@@ -794,6 +949,7 @@
 	}
 
 	val.uint_val = static_cast<bro_uint_t>(p);
+    val_type = BROVALUNION_UINT;
 	}
 
 PortVal::PortVal(uint32 p) : Val(TYPE_PORT)
@@ -805,6 +961,7 @@
 		}
 
 	val.uint_val = static_cast<bro_uint_t>(p);
+    val_type = BROVALUNION_UINT;
 	}
 
 uint32 PortVal::Port() const
@@ -856,25 +1013,44 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(PortVal,"PortVal")
+template<class Archive>
+void PortVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PortVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void PortVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PortVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 AddrVal::AddrVal(const char* text) : Val(TYPE_ADDR)
 	{
 	val.addr_val = new IPAddr(text);
+    val_type = BROVALUNION_ADDR;
 	}
 
 AddrVal::AddrVal(uint32 addr) : Val(TYPE_ADDR)
 	{
 	// ### perhaps do gethostbyaddr here?
 	val.addr_val = new IPAddr(IPv4, &addr, IPAddr::Network);
+    val_type = BROVALUNION_ADDR;
 	}
 
 AddrVal::AddrVal(const uint32 addr[4]) : Val(TYPE_ADDR)
 	{
 	val.addr_val = new IPAddr(IPv6, addr, IPAddr::Network);
+    val_type = BROVALUNION_ADDR;
 	}
 
 AddrVal::AddrVal(const IPAddr& addr) : Val(TYPE_ADDR)
 	{
 	val.addr_val = new IPAddr(addr);
+    val_type = BROVALUNION_ADDR;
 	}
 
 AddrVal::~AddrVal()
@@ -909,6 +1085,21 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(AddrVal,"AddrVal")
+template<class Archive>
+void AddrVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:AddrVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void AddrVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void AddrVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 SubNetVal::SubNetVal(const char* text) : Val(TYPE_SUBNET)
 	{
 	string s(text);
@@ -918,39 +1109,46 @@
 		{
 		reporter->Error("Bad string in SubNetVal ctor: %s", text);
 		val.subnet_val = new IPPrefix();
+        val_type = BROVALUNION_SUBNET;
 		}
 	else
 		{
 		val.subnet_val = new IPPrefix(s.substr(0, slash_loc),
 		                              atoi(s.substr(slash_loc + 1).c_str()));
+        val_type = BROVALUNION_SUBNET;
 		}
 	}
 
 SubNetVal::SubNetVal(const char* text, int width) : Val(TYPE_SUBNET)
 	{
 	val.subnet_val = new IPPrefix(text, width);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::SubNetVal(uint32 addr, int width) : Val(TYPE_SUBNET)
 	{
 	IPAddr a(IPv4, &addr, IPAddr::Network);
 	val.subnet_val = new IPPrefix(a, width);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::SubNetVal(const uint32* addr, int width) : Val(TYPE_SUBNET)
 	{
 	IPAddr a(IPv6, addr, IPAddr::Network);
 	val.subnet_val = new IPPrefix(a, width);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::SubNetVal(const IPAddr& addr, int width) : Val(TYPE_SUBNET)
 	{
 	val.subnet_val = new IPPrefix(addr, width);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::SubNetVal(const IPPrefix& prefix) : Val(TYPE_SUBNET)
 	{
 	val.subnet_val = new IPPrefix(prefix);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::~SubNetVal()
@@ -1033,20 +1231,38 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(SubNetVal,"SubNetVal")
+template<class Archive>
+void SubNetVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:SubNetVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void SubNetVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SubNetVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 StringVal::StringVal(BroString* s) : Val(TYPE_STRING)
 	{
 	val.string_val = s;
+    val_type = BROVALUNION_STRING;
 	}
 
 StringVal::StringVal(int length, const char* s) : Val(TYPE_STRING)
 	{
 	// The following adds a NUL at the end.
 	val.string_val = new BroString((const u_char*)  s, length, 1);
+    val_type = BROVALUNION_STRING;
 	}
 
 StringVal::StringVal(const char* s) : Val(TYPE_STRING)
 	{
 	val.string_val = new BroString(s);
+    val_type = BROVALUNION_STRING;
 	}
 
 StringVal* StringVal::ToUpper()
@@ -1084,9 +1300,25 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(StringVal,"StringVal")
+template<class Archive>
+void StringVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:StringVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void StringVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void StringVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 PatternVal::PatternVal(RE_Matcher* re) : Val(base_type(TYPE_PATTERN))
 	{
 	val.re_val = re;
+    val_type = BROVALUNION_RE;
 	}
 
 PatternVal::~PatternVal()
@@ -1118,6 +1350,7 @@
 	{
 	delete AsPattern();
 	val.re_val = re;
+    val_type = BROVALUNION_RE;
 	}
 
 void PatternVal::ValDescribe(ODesc* d) const
@@ -1145,9 +1378,25 @@
 	DO_UNSERIALIZE(Val);
 
 	val.re_val = RE_Matcher::Unserialize(info);
+    val_type = BROVALUNION_RE;
 	return val.re_val != 0;
 	}
 
+BOOST_CLASS_EXPORT_GUID(PatternVal,"PatternVal")
+template<class Archive>
+void PatternVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PatternVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void PatternVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PatternVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 ListVal::ListVal(TypeTag t)
 : Val(new TypeList(t == TYPE_ANY ? 0 : base_type(t)))
 	{
@@ -1303,7 +1552,39 @@
 		+ type->MemoryAllocation();
 	}
 
-
+BOOST_CLASS_EXPORT_GUID(ListVal,"ListVal")
+template<class Archive>
+void ListVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:ListVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+
+        ar & vals; 
+        ar & tag;
+    }
+template void ListVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ListVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
+BOOST_CLASS_EXPORT_GUID(TableEntryVal,"TableEntryVal")
+template<class Archive>
+void TableEntryVal::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & val;
+        ar & last_access_time;
+        ar & expire_access_time;
+        ar & last_read_update;
+    }
+template void TableEntryVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TableEntryVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 TableValTimer::TableValTimer(TableVal* val, double t) : Timer(t, TIMER_TABLE_VAL)
 	{
 	table = val;
@@ -1353,6 +1634,7 @@
 
 	table_hash = new CompositeHash(table_type->Indices());
 	val.table_val = new PDict(TableEntryVal);
+    val_type = BROVALUNION_TABLE;
 	val.table_val->SetDeleteFunc(table_entry_val_delete_func);
 	}
 
@@ -1375,6 +1657,7 @@
 	// Here we take the brute force approach.
 	delete AsTable();
 	val.table_val = new PDict(TableEntryVal);
+    val_type = BROVALUNION_TABLE;
 	val.table_val->SetDeleteFunc(table_entry_val_delete_func);
 	}
 
@@ -2547,11 +2830,41 @@
 		+ table_hash->MemoryAllocation();
 	}
 
+BOOST_CLASS_EXPORT_GUID(TableVal,"TableVal")
+template<class Archive>
+void TableVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TableVal:%d",__FILE__,__LINE__);
+        // Serialize MutableVal
+        ar & boost::serialization::base_object<MutableVal>(*this);
+
+        ar & table_type;
+        ar & table_hash;
+        ar & attrs;
+        ar & expire_time;
+        //ar & expire_expr; //FIXME
+        if (Archive::is_loading::value) { expire_expr = NULL; } //TMPHACK
+        //ar & timer; //FIXME
+        if (Archive::is_loading::value) { timer = NULL; } //TMPHACK
+        //ar & expire_cookie; //FIXME
+        if (Archive::is_loading::value) { expire_cookie = NULL; } //TMPHACK
+        //ar & subnets; //FIXME
+        if (Archive::is_loading::value) { subnets = NULL; } //TMPHACK
+        ar & def_val;
+    }
+template void TableVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TableVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 RecordVal::RecordVal(RecordType* t) : MutableVal(t)
 	{
 	record_type = t;
 	int n = record_type->NumFields();
 	val_list* vl = val.val_list_val = new val_list(n);
+    val_type = BROVALUNION_LIST;
 
 	// Initialize to default values from RecordType (which are nil
 	// by default).
@@ -2815,10 +3128,12 @@
 	if ( ! UNSERIALIZE(&len) )
 		{
 		val.val_list_val = new val_list;
+        val_type = BROVALUNION_LIST;
 		return false;
 		}
 
 	val.val_list_val = new val_list(len);
+    val_type = BROVALUNION_LIST;
 
 	for ( int i = 0; i < len; ++i )
 		{
@@ -2881,6 +3196,25 @@
 	return size + padded_sizeof(*this) + val.val_list_val->MemoryAllocation();
 	}
 
+BOOST_CLASS_EXPORT_GUID(RecordVal,"RecordVal")
+template<class Archive>
+void RecordVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:RecordVal:%d",__FILE__,__LINE__);
+        // Serialize MutableVal
+        ar & boost::serialization::base_object<MutableVal>(*this);
+
+        ar & record_type;
+//        ar & origin; //REINCLUDE
+        if (Archive::is_loading::value) { origin = NULL; } //TMPHACK
+    }
+template void RecordVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void RecordVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 void EnumVal::ValDescribe(ODesc* d) const
 	{
 	const char* ename = type->AsEnumType()->Lookup(val.int_val);
@@ -2905,10 +3239,26 @@
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(EnumVal,"EnumVal")
+template<class Archive>
+void EnumVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:EnumVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void EnumVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void EnumVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 VectorVal::VectorVal(VectorType* t) : MutableVal(t)
 	{
 	vector_type = t->Ref()->AsVectorType();
 	val.vector_val = new vector<Val*>();
+    val_type = BROVALUNION_VECTOR;
 	}
 
 VectorVal::~VectorVal()
@@ -3079,6 +3429,7 @@
 	DO_UNSERIALIZE(MutableVal);
 
 	val.vector_val = new vector<Val*>;
+    val_type = BROVALUNION_VECTOR;
 	vector_type = type->Ref()->AsVectorType();
 
 	int len;
@@ -3114,6 +3465,22 @@
 	d->Add("]");
 	}
 
+BOOST_CLASS_EXPORT_GUID(VectorVal,"VectorVal")
+template<class Archive>
+void VectorVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:VectorVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+
+        ar & vector_type;
+    }
+template void VectorVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void VectorVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 Val* check_and_promote(Val* v, const BroType* t, int is_init)
 	{
diff -urN bro-2.1/src/Val.h bro-2.1-sdmbn/src/Val.h
--- bro-2.1/src/Val.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/Val.h	2014-02-17 17:20:07.000000003 -0600
@@ -19,6 +19,7 @@
 #include "Scope.h"
 #include "StateAccess.h"
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 class Val;
 class Func;
@@ -47,6 +48,21 @@
 class TableEntryVal;
 declare(PDict,TableEntryVal);
 
+typedef enum {
+    BROVALUNION_INT,
+    BROVALUNION_UINT,
+    BROVALUNION_ADDR,
+    BROVALUNION_SUBNET,
+    BROVALUNION_DOUBLE,
+    BROVALUNION_STRING,
+    BROVALUNION_FUNC,
+    BROVALUNION_FILE,
+    BROVALUNION_RE,
+    BROVALUNION_TABLE,
+    BROVALUNION_LIST,
+    BROVALUNION_VECTOR
+} BroValUnionType;
+
 typedef union {
 	// Used for bool, int, enum.
 	bro_int_t int_val;
@@ -79,6 +95,7 @@
 	Val(bool b, TypeTag t)
 		{
 		val.int_val = b;
+        val_type = BROVALUNION_INT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -89,6 +106,7 @@
 	Val(int32 i, TypeTag t)
 		{
 		val.int_val = bro_int_t(i);
+        val_type = BROVALUNION_INT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -99,6 +117,7 @@
 	Val(uint32 u, TypeTag t)
 		{
 		val.uint_val = bro_uint_t(u);
+        val_type = BROVALUNION_UINT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -109,6 +128,7 @@
 	Val(int64 i, TypeTag t)
 		{
 		val.int_val = i;
+        val_type = BROVALUNION_INT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -119,6 +139,7 @@
 	Val(uint64 u, TypeTag t)
 		{
 		val.uint_val = u;
+        val_type = BROVALUNION_UINT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -129,6 +150,7 @@
 	Val(double d, TypeTag t)
 		{
 		val.double_val = d;
+        val_type = BROVALUNION_DOUBLE;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -154,6 +176,7 @@
 	Val()
 		{
 		val.int_val = 0;
+        val_type = BROVALUNION_INT;
 		type = base_type(TYPE_ERROR);
 		attribs = 0;
 #ifdef DEBUG
@@ -363,6 +386,7 @@
 	Val(BroString* s, TypeTag t)
 		{
 		val.string_val = s;
+        val_type = BROVALUNION_STRING;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -399,6 +423,7 @@
 			const BroType* exact_type);
 
 	BroValUnion val;
+    BroValUnionType val_type;
 	BroType* type;
 	RecordVal* attribs;
 
@@ -407,6 +432,9 @@
 	const char* bound_id;
 #endif
 
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class MutableVal : public Val {
@@ -483,6 +511,10 @@
 	list<ID*> aliases;
 	Properties props;
 	uint64 last_modified;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #define Microseconds 1e-6
@@ -502,6 +534,10 @@
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(IntervalVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 
@@ -550,6 +586,10 @@
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(PortVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class AddrVal : public Val {
@@ -573,6 +613,10 @@
 	AddrVal(BroType* t) : Val(t)	{ }
 
 	DECLARE_SERIAL(AddrVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class SubNetVal : public Val {
@@ -602,6 +646,10 @@
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(SubNetVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class StringVal : public Val {
@@ -633,6 +681,10 @@
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(StringVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class PatternVal : public Val {
@@ -653,6 +705,10 @@
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(PatternVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class ListVal : public Val {
@@ -705,6 +761,10 @@
 
 	val_list vals;
 	TypeTag tag;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 extern double bro_start_network_time;
@@ -748,6 +808,12 @@
 	// for these anyway.
 	int expire_access_time;
 	int last_read_update;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TableEntryVal() {}; // Dummy default constructor for serialization
 };
 
 class TableValTimer : public Timer {
@@ -880,6 +946,10 @@
 	IterCookie* expire_cookie;
 	PrefixTable* subnets;
 	Val* def_val;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class RecordVal : public MutableVal {
@@ -929,6 +999,10 @@
 
 	RecordType* record_type;
 	BroObj* origin;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class EnumVal : public Val {
@@ -949,6 +1023,10 @@
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(EnumVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 
@@ -1011,6 +1089,10 @@
 	DECLARE_SERIAL(VectorVal);
 
 	VectorType* vector_type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 
diff -urN bro-2.1/src/ZIP.cc bro-2.1-sdmbn/src/ZIP.cc
--- bro-2.1/src/ZIP.cc	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ZIP.cc	2014-02-17 17:20:07.000000003 -0600
@@ -1,6 +1,10 @@
 // See the file "COPYING" in the main distribution directory for copyright.
 
 #include "ZIP.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 ZIP_Analyzer::ZIP_Analyzer(Connection* conn, bool orig, Method arg_method)
 : TCP_SupportAnalyzer(AnalyzerTag::Zip, conn, orig)
@@ -87,3 +91,51 @@
 		}
 	while ( zip->avail_out == 0 );
 	}
+
+BOOST_CLASS_EXPORT_GUID(ZIP_Analyzer,"ZIP_Analyzer")
+template<class Archive>
+void ZIP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:ZIP_Analzyer:%d\n",__FILE__,__LINE__);
+        // Serialize TCP_SupportAnalyzer 
+        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
+
+        //ar & zip; //FIXME
+//        int zipnull;
+//        if (!Archive::is_loading::value)
+//        {
+//            if (NULL == zip)
+//            { zipnull = 1; }
+//            else
+//            { zipnull = 0; }
+//        }
+//        ar & zipnull;
+//        if (!zipnull)
+//        {
+//            //ar & zip->next_in; //FIXME
+//            ar & zip->avail_in;
+//            ar & zip->total_in;
+//            //ar & zip->next_out; //FIXME
+//            ar & zip->avail_out;
+//            ar & zip->total_out;
+//            //ar & zip->msg; //FIXME
+//            //ar & zip->state; //FIXME
+//            //zalloc, zfree, and opaque are always null? //FIXME
+//            ar & zip->data_type;
+//            ar & zip->adler;
+//            ar & zip->reserved;
+//        }
+//        else
+//        { zip = NULL; }
+//
+        if (Archive::is_loading::value) { zip = NULL; } //TMPHACK
+        ar & zip_status;
+        if (Archive::is_loading::value) { zip_status = Z_BUF_ERROR; } //TMPHACK
+        ar & method;
+    }
+template void ZIP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ZIP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff -urN bro-2.1/src/ZIP.h bro-2.1-sdmbn/src/ZIP.h
--- bro-2.1/src/ZIP.h	2012-08-29 10:44:07.000000003 -0500
+++ bro-2.1-sdmbn/src/ZIP.h	2014-02-17 17:20:07.000000003 -0600
@@ -7,6 +7,7 @@
 
 #include "zlib.h"
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
 
 class ZIP_Analyzer : public TCP_SupportAnalyzer {
 public:
@@ -24,6 +25,12 @@
 	z_stream* zip;
 	int zip_status;
 	Method method;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    ZIP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff -urN bro-2.1/wisconsin_build.sh bro-2.1-sdmbn/wisconsin_build.sh
--- bro-2.1/wisconsin_build.sh	1969-12-31 18:00:00.000000000 -0600
+++ bro-2.1-sdmbn/wisconsin_build.sh	2014-04-15 13:53:57.000000003 -0500
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+BASEDIR="/scratch/${USER}/tools"
+export CFLAGS="-I${BASEDIR}/json-c/include/ -I${BASEDIR}/sdmbn/include/ -g"
+export CXXFLAGS="-I${BASEDIR}/json-c/include/ -I${BASEDIR}/sdmbn/include/ -g"
+export LDFLAGS="-L${BASEDIR}/json-c/lib/ -L${BASEDIR}/sdmbn/lib/ -L/usr/local/lib/ -lsdmbn -ljson-c -lboost_serialization"
+
+export LD_LIBRARY_PATH="${BASEDIR}/json-c/lib:${BASEDIR}/sdmbn/lib" 
+
+./configure --prefix=${BASEDIR}/bro-sdmbn 
+sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/link.txt
+sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/link.txt
+make install
